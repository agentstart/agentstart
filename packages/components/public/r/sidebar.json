{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "sidebar",
  "type": "registry:component",
  "title": "AgentStart Sidebar",
  "description": "A shadcn-based sidebar component that displays AgentStart threads with TanStack Query for data fetching, infinite scroll pagination, and thread management capabilities.",
  "dependencies": [
    "@tanstack/react-query",
    "@agentstart/utils",
    "agentstart",
    "lucide-react",
    "react"
  ],
  "registryDependencies": [
    "button",
    "scroll-area",
    "sidebar"
  ],
  "files": [
    {
      "path": "src/registry/agentstart/sidebar/sidebar.tsx",
      "content": "/* agent-frontmatter:start\nAGENT: Sidebar layout\nPURPOSE: Compose a shadcn sidebar that lists AgentStart threads using TanStack Query\nUSAGE: <Sidebar>{mainContent}</Sidebar>\nEXPORTS: Sidebar, SidebarProps\nFEATURES:\n  - Fetches threads via TanStack Query with automatic caching and refetching\n  - Supports infinite scroll pagination, thread creation, and selection callbacks\n  - Wraps children inside <SidebarInset> for a ready-to-use layout\nSEARCHABLE: agent layout, sidebar, agent threads list, tanstack query\nagent-frontmatter:end */\n\n\"use client\";\n\nimport {\n  useInfiniteQuery,\n  useMutation,\n  useQueryClient,\n} from \"@tanstack/react-query\";\nimport type { DBThread } from \"agentstart/db\";\nimport {\n  AlertCircleIcon,\n  InboxIcon,\n  Loader2Icon,\n  PlusIcon,\n  RotateCcwIcon,\n} from \"lucide-react\";\nimport {\n  type ReactNode,\n  useCallback,\n  useEffect,\n  useMemo,\n  useState,\n} from \"react\";\nimport { Button } from \"@/components/ui/button\";\nimport { ScrollArea } from \"@/components/ui/scroll-area\";\nimport {\n  Sidebar as ShadcnSidebar,\n  SidebarContent,\n  SidebarFooter,\n  SidebarGroup,\n  SidebarGroupContent,\n  SidebarGroupLabel,\n  SidebarHeader,\n  SidebarInset,\n  SidebarMenu,\n  SidebarMenuBadge,\n  SidebarMenuButton,\n  SidebarMenuItem,\n  SidebarMenuSkeleton,\n  SidebarProvider,\n  SidebarRail,\n  SidebarSeparator,\n  SidebarTrigger,\n} from \"@/components/ui/sidebar\";\nimport { cn } from \"@/lib/utils\";\nimport { useAgentStartContext } from \"../provider\";\nimport { SidebarItem } from \"./sidebar-item\";\n\nexport type SidebarProps = {\n  children?: ReactNode;\n  className?: string;\n  // Thread selection\n  selectedThreadId?: string;\n  defaultSelectedThreadId?: string;\n  autoSelectFirst?: boolean;\n  onSelectThread?: (thread: DBThread) => void;\n  onThreadCreated?: (thread: DBThread) => void;\n  // Query configuration\n  pageSize?: number;\n  queryKey?: unknown[];\n  // UI customization\n  header?: {\n    title?: string;\n    description?: string;\n    actions?: ReactNode;\n  };\n  footer?: ReactNode;\n  emptyState?: ReactNode;\n  errorState?: (error: Error, retry: () => void) => ReactNode;\n  // Sidebar configuration\n  sidebar?: {\n    variant?: \"sidebar\" | \"floating\" | \"inset\";\n    side?: \"left\" | \"right\";\n    collapsible?: \"offcanvas\" | \"icon\" | \"none\";\n    className?: string;\n    defaultOpen?: boolean;\n    open?: boolean;\n    onOpenChange?: (open: boolean) => void;\n  };\n};\n\nexport function Sidebar({\n  children,\n  className,\n  selectedThreadId,\n  defaultSelectedThreadId,\n  autoSelectFirst = true,\n  onSelectThread,\n  onThreadCreated,\n  pageSize = 20,\n  queryKey = [\"threads\"],\n  header,\n  footer,\n  emptyState,\n  errorState,\n  sidebar,\n}: SidebarProps) {\n  const { client } = useAgentStartContext();\n  const queryClient = useQueryClient();\n\n  const [internalSelectedId, setInternalSelectedId] = useState<string | null>(\n    defaultSelectedThreadId ?? null,\n  );\n\n  const showCreateButton = typeof client.thread.create === \"function\";\n\n  // Infinite query for thread list with pagination\n  const {\n    data,\n    error,\n    fetchNextPage,\n    hasNextPage,\n    isFetching,\n    isFetchingNextPage,\n    isLoading,\n    isError,\n    refetch,\n  } = useInfiniteQuery({\n    queryKey,\n    queryFn: async ({ pageParam = 1 }) => {\n      const response = await client.thread.list({\n        page: pageParam,\n        pageSize,\n      });\n      return response;\n    },\n    initialPageParam: 1,\n    getNextPageParam: (lastPage) => {\n      if (lastPage.pageInfo.hasNextPage) {\n        return lastPage.pageInfo.page + 1;\n      }\n      return undefined;\n    },\n  });\n\n  // Mutation for creating new thread\n  const createThreadMutation = useMutation({\n    mutationFn: async () => {\n      if (!client.thread.create) {\n        throw new Error(\"Thread creation is not supported\");\n      }\n      const result = await client.thread.create();\n      return result.thread;\n    },\n    onSuccess: (thread) => {\n      // Invalidate and refetch threads\n      queryClient.invalidateQueries({ queryKey });\n      setInternalSelectedId(thread.id);\n      onThreadCreated?.(thread);\n      onSelectThread?.(thread);\n    },\n  });\n\n  // Flatten all pages into a single array of threads\n  const threads = useMemo(() => {\n    if (!data) return [];\n    return data.pages.flatMap((page) =>\n      page.threads.map((thread) => normalizeThread(thread)),\n    );\n  }, [data]);\n\n  // Auto-select first thread\n  useEffect(() => {\n    if (selectedThreadId !== undefined) {\n      setInternalSelectedId(selectedThreadId);\n    }\n  }, [selectedThreadId]);\n\n  useEffect(() => {\n    if (\n      autoSelectFirst &&\n      selectedThreadId === undefined &&\n      !internalSelectedId &&\n      threads.length > 0\n    ) {\n      const firstThread = threads[0];\n      if (!firstThread) {\n        return;\n      }\n      setInternalSelectedId(firstThread.id);\n      onSelectThread?.(firstThread);\n    }\n  }, [\n    autoSelectFirst,\n    internalSelectedId,\n    onSelectThread,\n    selectedThreadId,\n    threads,\n  ]);\n\n  // Clear selection if thread no longer exists\n  useEffect(() => {\n    if (\n      internalSelectedId &&\n      threads.length > 0 &&\n      !threads.some((thread) => thread.id === internalSelectedId)\n    ) {\n      setInternalSelectedId(null);\n    }\n  }, [internalSelectedId, threads]);\n\n  const activeThreadId = selectedThreadId ?? internalSelectedId ?? null;\n\n  const handleSelectThread = useCallback(\n    (thread: DBThread) => {\n      if (selectedThreadId === undefined) {\n        setInternalSelectedId(thread.id);\n      }\n      onSelectThread?.(thread);\n    },\n    [onSelectThread, selectedThreadId],\n  );\n\n  const renderThreads = useMemo(() => {\n    if (isLoading && threads.length === 0) {\n      return Array.from({ length: 6 }).map((_, index) => (\n        <SidebarMenuSkeleton key={`thread-skeleton-${index}`} showIcon />\n      ));\n    }\n\n    if (isError && error) {\n      if (errorState) {\n        return errorState(error, refetch);\n      }\n      return (\n        <SidebarMenuItem>\n          <SidebarMenuButton\n            type=\"button\"\n            variant=\"outline\"\n            className=\"items-start gap-3 text-left\"\n            onClick={() => refetch()}\n          >\n            <AlertCircleIcon className=\"mt-0.5 size-4 text-destructive\" />\n            <div className=\"space-y-1\">\n              <p className=\"font-medium text-destructive text-sm\">\n                Failed to load threads\n              </p>\n              <p className=\"text-muted-foreground text-xs\">{error.message}</p>\n              <Button\n                type=\"button\"\n                variant=\"ghost\"\n                size=\"sm\"\n                className=\"h-7 justify-start px-0 text-xs\"\n                onClick={() => refetch()}\n              >\n                Retry\n              </Button>\n            </div>\n          </SidebarMenuButton>\n        </SidebarMenuItem>\n      );\n    }\n\n    if (threads.length === 0) {\n      if (emptyState) {\n        return emptyState;\n      }\n      return (\n        <SidebarMenuItem>\n          <SidebarMenuButton\n            type=\"button\"\n            disabled\n            className=\"items-start gap-3 text-left\"\n          >\n            <InboxIcon className=\"mt-0.5 size-4 text-muted-foreground\" />\n            <div className=\"space-y-1\">\n              <p className=\"font-medium text-sm\">No threads yet</p>\n              <p className=\"text-muted-foreground text-xs\">\n                Start chatting with the agent to see conversations here.\n              </p>\n            </div>\n          </SidebarMenuButton>\n        </SidebarMenuItem>\n      );\n    }\n\n    const items = threads.map((thread) => (\n      <SidebarItem\n        key={thread.id}\n        thread={thread}\n        isActive={thread.id === activeThreadId}\n        onSelect={handleSelectThread}\n        leading={<ThreadAvatar title={thread.title} />}\n        trailing={\n          thread.visibility === \"public\" ? (\n            <SidebarMenuBadge className=\"uppercase\">Public</SidebarMenuBadge>\n          ) : null\n        }\n      />\n    ));\n\n    if (isFetching && threads.length > 0) {\n      items.push(\n        ...Array.from({ length: 3 }).map((_, index) => (\n          <SidebarMenuSkeleton\n            key={`thread-refresh-skeleton-${index}`}\n            showIcon\n          />\n        )),\n      );\n    }\n\n    return items;\n  }, [\n    activeThreadId,\n    emptyState,\n    error,\n    errorState,\n    refetch,\n    handleSelectThread,\n    isError,\n    isFetching,\n    isLoading,\n    threads,\n  ]);\n\n  return (\n    <SidebarProvider\n      defaultOpen={sidebar?.defaultOpen}\n      open={sidebar?.open}\n      onOpenChange={sidebar?.onOpenChange}\n      className={className}\n    >\n      <ShadcnSidebar\n        variant={sidebar?.variant ?? \"sidebar\"}\n        side={sidebar?.side ?? \"left\"}\n        collapsible={sidebar?.collapsible ?? \"icon\"}\n        className={cn(\n          sidebar?.side === \"right\" ? \"border-l\" : \"border-r\",\n          \"border-sidebar-border/60\",\n          sidebar?.className,\n        )}\n      >\n        <SidebarHeader className=\"border-sidebar-border border-b px-3 py-4\">\n          <div className=\"flex items-center justify-between gap-2\">\n            <div className=\"flex items-center gap-2\">\n              <SidebarTrigger className=\"md:hidden\" />\n              <div className=\"flex min-w-0 flex-col\">\n                <span className=\"truncate font-semibold text-sm\">\n                  {header?.title ?? \"Threads\"}\n                </span>\n                {header?.description ? (\n                  <span className=\"truncate text-muted-foreground text-xs\">\n                    {header.description}\n                  </span>\n                ) : null}\n              </div>\n            </div>\n            <div className=\"flex items-center gap-1\">\n              <Button\n                type=\"button\"\n                variant=\"ghost\"\n                size=\"icon\"\n                onClick={() => refetch()}\n                disabled={isFetching}\n              >\n                <RotateCcwIcon\n                  className={cn(\"size-4\", isFetching && \"animate-spin\")}\n                />\n                <span className=\"sr-only\">Refresh threads</span>\n              </Button>\n              {showCreateButton ? (\n                <Button\n                  type=\"button\"\n                  size=\"icon\"\n                  onClick={() => createThreadMutation.mutate()}\n                  disabled={createThreadMutation.isPending}\n                >\n                  {createThreadMutation.isPending ? (\n                    <Loader2Icon className=\"size-4 animate-spin\" />\n                  ) : (\n                    <PlusIcon className=\"size-4\" />\n                  )}\n                  <span className=\"sr-only\">Create thread</span>\n                </Button>\n              ) : null}\n              {header?.actions}\n            </div>\n          </div>\n        </SidebarHeader>\n        <SidebarContent>\n          <SidebarGroup>\n            <SidebarGroupLabel>Recent conversations</SidebarGroupLabel>\n            <SidebarGroupContent>\n              <ScrollArea className=\"h-[calc(100vh-14rem)] pr-2 md:h-[calc(100vh-12rem)]\">\n                <SidebarMenu>{renderThreads}</SidebarMenu>\n              </ScrollArea>\n            </SidebarGroupContent>\n          </SidebarGroup>\n          {hasNextPage ? (\n            <>\n              <SidebarSeparator />\n              <SidebarGroup>\n                <SidebarGroupContent>\n                  <SidebarMenu>\n                    <SidebarMenuItem>\n                      <SidebarMenuButton\n                        type=\"button\"\n                        variant=\"outline\"\n                        disabled={isFetchingNextPage}\n                        onClick={() => {\n                          if (hasNextPage && !isFetchingNextPage) {\n                            fetchNextPage();\n                          }\n                        }}\n                      >\n                        {isFetchingNextPage ? (\n                          <>\n                            <Loader2Icon className=\"mr-2 size-4 animate-spin\" />\n                            Loading more…\n                          </>\n                        ) : (\n                          \"Load more\"\n                        )}\n                      </SidebarMenuButton>\n                    </SidebarMenuItem>\n                  </SidebarMenu>\n                </SidebarGroupContent>\n              </SidebarGroup>\n            </>\n          ) : null}\n        </SidebarContent>\n        {footer ? <SidebarFooter>{footer}</SidebarFooter> : null}\n        <SidebarRail />\n      </ShadcnSidebar>\n      <SidebarInset>{children}</SidebarInset>\n    </SidebarProvider>\n  );\n}\n\nfunction normalizeThread(thread: DBThread): DBThread {\n  const createdAt =\n    thread.createdAt instanceof Date\n      ? thread.createdAt\n      : new Date(thread.createdAt);\n  const updatedAt =\n    thread.updatedAt instanceof Date\n      ? thread.updatedAt\n      : new Date(thread.updatedAt);\n\n  return {\n    ...thread,\n    createdAt,\n    updatedAt,\n  };\n}\n\nfunction ThreadAvatar({ title }: { title?: string | null }) {\n  const initials = (title ?? \"Thread\")\n    .split(\" \")\n    .filter(Boolean)\n    .map((segment) => segment[0]?.toUpperCase())\n    .join(\"\")\n    .slice(0, 2);\n\n  return (\n    <div className=\"flex size-8 items-center justify-center rounded-md border border-sidebar-border bg-sidebar-accent/40 font-semibold text-[11px] text-sidebar-foreground uppercase\">\n      {initials || \"AI\"}\n    </div>\n  );\n}\n",
      "type": "registry:component",
      "target": "components/agent/sidebar/sidebar.tsx"
    },
    {
      "path": "src/registry/agentstart/sidebar/sidebar-item.tsx",
      "content": "/* agent-frontmatter:start\nAGENT: Sidebar item\nPURPOSE: Render a single thread row inside the agent sidebar\nUSAGE: <SidebarItem thread={thread} onSelect={handleSelect} />\nEXPORTS: SidebarItem, SidebarItemProps\nFEATURES:\n  - Displays title, timestamp, and optional leading/trailing content\n  - Supports active and disabled states for navigation\n  - Computes human-readable relative timestamps by default\nSEARCHABLE: agent layout, list item, sidebar row\nagent-frontmatter:end */\n\n\"use client\";\n\nimport { formatRelativeFromNow } from \"@agentstart/utils\";\nimport type { DBThread } from \"agentstart/db\";\nimport type { ReactNode } from \"react\";\nimport { memo, useMemo } from \"react\";\nimport { SidebarMenuButton, SidebarMenuItem } from \"@/components/ui/sidebar\";\n\nexport type SidebarItemProps = {\n  thread: DBThread;\n  leading?: ReactNode;\n  trailing?: ReactNode;\n  secondaryText?: ReactNode;\n  isActive?: boolean;\n  disabled?: boolean;\n  className?: string;\n  onSelect?: (thread: DBThread) => void;\n};\n\nexport const SidebarItem = memo(function SidebarItem({\n  thread,\n  leading,\n  trailing,\n  secondaryText,\n  isActive = false,\n  disabled = false,\n  className,\n  onSelect,\n}: SidebarItemProps) {\n  const computedSecondaryText = useMemo(() => {\n    if (secondaryText === null) {\n      return null;\n    }\n    if (secondaryText !== undefined) {\n      return secondaryText;\n    }\n    return formatRelativeFromNow(thread.updatedAt ?? thread.createdAt);\n  }, [secondaryText, thread.createdAt, thread.updatedAt]);\n\n  return (\n    <SidebarMenuItem className={className}>\n      <SidebarMenuButton\n        type=\"button\"\n        isActive={isActive}\n        disabled={disabled}\n        onClick={() => {\n          if (!disabled) {\n            onSelect?.(thread);\n          }\n        }}\n      >\n        <div className=\"flex w-full items-center gap-3\">\n          {leading ? <div className=\"shrink-0\">{leading}</div> : null}\n          <div className=\"flex min-w-0 flex-1 flex-col text-left\">\n            <span className=\"truncate font-medium text-sm\">\n              {thread.title || \"Untitled thread\"}\n            </span>\n            {computedSecondaryText ? (\n              <span className=\"truncate text-muted-foreground text-xs\">\n                {computedSecondaryText}\n              </span>\n            ) : null}\n          </div>\n          {trailing ? <div className=\"shrink-0\">{trailing}</div> : null}\n        </div>\n      </SidebarMenuButton>\n    </SidebarMenuItem>\n  );\n});\n",
      "type": "registry:component",
      "target": "components/agent/sidebar/sidebar-item.tsx"
    }
  ]
}