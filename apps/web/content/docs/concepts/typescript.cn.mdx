---
title: TypeScript
description: AgentStart 的 TypeScript 集成
---

# TypeScript

AgentStart 设计为完全类型安全。客户端和服务器都使用 TypeScript 构建，提供端到端的类型安全。

## TypeScript 配置

### 严格模式

AgentStart 设计为与 TypeScript 的严格模式配合使用。我们建议启用它：

```json title="tsconfig.json"
{
  "compilerOptions": {
    "strict": true
  }
}
```

如果无法启用 `strict`，至少启用 `strictNullChecks`：

```json title="tsconfig.json"
{
  "compilerOptions": {
    "strictNullChecks": true
  }
}
```

## 类型推断

客户端 SDK 和服务器 API 都为所有实体提供类型推断。

### 服务器端类型

```ts title="lib/agent.ts"
import { agentStart } from "agentstart";
import { Agent } from "agentstart/agent";

const agent = new Agent({
  model: openrouter("x-ai/grok-4-fast"),
  instructions: "你是一个乐于助人的助手。",
  tools: { ...innerTools, ...osTools },
});

export const start = agentStart({ agent, memory });

// 从 start 实例推断类型
export type Thread = Awaited<ReturnType<typeof start.api.thread.get>>;
export type Message = Awaited<ReturnType<typeof start.api.message.list>>[number];
```

### 客户端类型

```ts title="lib/agent-client.ts"
import { createAgentClient } from "agentstart/client";

export const { client, useThread } = createAgentClient();

// 客户端提供类型化的 hooks 和方法
const sendMessage = useAgentStore((state) => state.sendMessage, threadId);
//    ^? (params: { content: string }) => Promise<void>
```

## 工具类型

工具使用 Zod 架构完全类型化：

```ts
import { z } from "zod";

const weatherTool = {
  description: "获取当前天气",
  parameters: z.object({
    location: z.string().describe("城市名称"),
    units: z.enum(["celsius", "fahrenheit"]).default("celsius"),
  }),
  execute: async ({ location, units }) => {
    // location: string
    // units: "celsius" | "fahrenheit"
    return { temperature: 72, units };
  },
};
```

TypeScript 从 Zod 架构推断参数类型：

```ts
// ✅ 正确
await weatherTool.execute({ 
  location: "旧金山",
  units: "celsius" 
});

// ❌ TypeScript 错误
await weatherTool.execute({ 
  location: 123,  // 类型错误：期望字符串
  units: "kelvin" // 类型错误：不在枚举中
});
```

## Agent Store 类型

智能体存储完全类型化：

```tsx
import { useAgentStore } from "@/lib/agent-client";

// 所有状态都是类型化的
const messages = useAgentStore((state) => state.messages, threadId);
//    ^? Message[]

const isLoading = useAgentStore((state) => state.isLoading, threadId);
//    ^? boolean

const sendMessage = useAgentStore((state) => state.sendMessage, threadId);
//    ^? (params: { content: string }) => Promise<void>
```

## 自定义工具类型

为复杂工具定义自定义类型：

```ts
import { z } from "zod";

const FileOperationSchema = z.object({
  operation: z.enum(["read", "write", "delete"]),
  path: z.string(),
  content: z.string().optional(),
});

type FileOperation = z.infer<typeof FileOperationSchema>;

const fileTool = {
  description: "文件操作",
  parameters: FileOperationSchema,
  execute: async (params: FileOperation) => {
    // params 完全类型化
    if (params.operation === "write") {
      // TypeScript 知道 content 存在
      const content = params.content!;
    }
  },
};
```

## API 响应类型

所有 API 响应都是类型化的：

```ts
// Thread 类型被推断
const thread = await start.api.thread.create({ title: "新线程" });
//    ^? { id: string; title: string; userId: string | null; createdAt: Date; metadata: unknown }

// Message 类型被推断
const messages = await start.api.message.list({ threadId: thread.id });
//    ^? Array<{ id: string; threadId: string; role: string; content: string; ... }>
```

## 类型守卫

使用类型守卫进行运行时类型检查：

```ts
function isTextMessage(message: Message): message is Message & { content: string } {
  return typeof message.content === "string";
}

const messages = await start.api.message.list({ threadId });
const textMessages = messages.filter(isTextMessage);
```

## 泛型类型

AgentStart 导出有用的泛型类型：

```ts
import type { 
  Agent,
  Thread,
  Message,
  Tool,
  ToolExecutor,
  DatabaseAdapter,
} from "agentstart";
```

## 下一步

<Cards>
  <Card title="API" href="/docs/concepts/api" />
  <Card title="客户端" href="/docs/concepts/client" />
</Cards>
