---
title: Database
description: Learn how to use databases with AgentStart
---

AgentStart requires a primary database to persist threads, messages, and agent metadata. This page explains supported adapters, the CLI workflow to generate tables, optional secondary storage, the core schema, and how to extend with custom tables.

## Adapters

Choose the adapter that matches your stack. AgentStart supports:

- **PostgreSQL** – Drizzle, Prisma, or Kysely
- **MySQL** – Drizzle, Prisma, or Kysely
- **SQLite** – Drizzle, Prisma, or Kysely
- **MongoDB** – native driver
- **In‑Memory** – local dev and tests only

Adapter guides:

<Cards>
  <Card title="Drizzle" href="/docs/databases/drizzle" />

  <Card title="Prisma" href="/docs/databases/prisma" />

  <Card title="MongoDB" href="/docs/databases/mongodb" />
</Cards>

## CLI

Use the CLI to generate and apply the minimal tables AgentStart needs. The CLI reads your agent configuration to tailor output for your stack.

### Generate schema

```bash title="Terminal"
npx @agentstart/cli generate
```

- For Drizzle/Prisma: emits ORM schema you can commit and migrate with your toolchain.
- For Kysely: emits a portable `schema.sql` you can apply directly.

See details and options in the CLI docs: `/docs/concepts/cli`.

### Apply schema

- Kysely users can run `npx @agentstart/cli migrate`.
- Drizzle/Prisma users should use their ORM’s migration commands.

Refer to the Migration section in `/docs/concepts/cli` for exact commands.

## Secondary Storage

Some runtime features rely on storage beyond the primary database:

- **Blob storage** – persists file uploads and multimodal attachments used by tools and messages. Providers supported: Vercel Blob, AWS S3, Cloudflare R2.
- **Secondary memory** – a key-value store (Redis, Upstash, Vercel KV, etc.) that tracks sandbox heartbeats and enables the E2B sandbox adapter to resume work across processes.

Blob storage is optional and configured in your agent setup. See `/docs/concepts/blob-storage` for providers, constraints, and client utilities. Secondary memory is configured through `agentStart({ secondaryMemory: ... })` and documented in `/docs/concepts/secondary-memory`; it is required when you opt into the E2B sandbox adapter.

## Core Schema

AgentStart always needs thread and message tables. If you enable the built-in `agentTools` (the default quickstart configuration), add the todos table so task management persists.

### Threads Table

Stores conversation sessions:

```sql
CREATE TABLE threads (
  id TEXT PRIMARY KEY,
  title TEXT,
  user_id TEXT,
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  metadata JSONB
);
```

### Messages Table

Stores individual messages:

```sql
CREATE TABLE messages (
  id TEXT PRIMARY KEY,
  thread_id TEXT REFERENCES threads(id),
  role TEXT,
  content TEXT, -- or "parts" JSON depending on adapter
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  metadata JSONB
);
```

Recommended indexes for performance:

```sql
CREATE INDEX idx_messages_thread_id ON messages(thread_id);
CREATE INDEX idx_threads_user_id ON threads(user_id);
```

### Todos Table

Persists the task list used by the `todoRead` and `todoWrite` tools:

```sql
CREATE TABLE todos (
  id TEXT PRIMARY KEY,
  thread_id TEXT NOT NULL REFERENCES threads(id) ON DELETE CASCADE,
  todos JSONB NOT NULL,
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);
```

If you skip `agentTools`, you can omit this table.

## Connection Management

### Connection Pooling

Always use connection pooling in production:

```ts
import { Pool } from "pg";

const pool = new Pool({
  connectionString: process.env.DATABASE_URL,
  max: 20,  // Maximum pool size
});
```

### Connection String

Use environment variables for database URLs:

```bash
# PostgreSQL
DATABASE_URL=postgresql://user:password@localhost:5432/dbname

# MySQL
DATABASE_URL=mysql://user:password@localhost:3306/dbname

# MongoDB
DATABASE_URL=mongodb://localhost:27017/dbname
```

## Custom Tables

You can extend the schema with application‑specific tables or additional columns. Common patterns:

- Add indexes for frequent filters (e.g., `thread_id`, `user_id`, timestamps).
- Store structured payloads in `metadata` JSONB and index selected keys if needed.
- Create domain tables (e.g., tasks, todos) that reference `threads(id)`.

Example custom table for storing generated artifacts:

```sql
CREATE TABLE artifacts (
  id TEXT PRIMARY KEY,
  thread_id TEXT NOT NULL REFERENCES threads(id) ON DELETE CASCADE,
  type TEXT NOT NULL,
  payload JSONB NOT NULL,
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);
```

Cleanup and retention:

```sql
-- Example: remove threads older than 90 days
DELETE FROM threads WHERE created_at < NOW() - INTERVAL '90 days';
```

Operational best practices:

- Backups: enable automated backups for production.
- Monitoring: track query latency and pool utilization.
- Migrations: manage schema via your ORM or the CLI where applicable.

## Next Steps

<Cards>
  <Card title="PostgreSQL" href="/docs/databases/postgresql" />

  <Card title="MySQL" href="/docs/databases/mysql" />

  <Card title="Drizzle Adapter" href="/docs/databases/drizzle" />
  
  <Card title="CLI" href="/docs/concepts/cli" />
  
  <Card title="Blob Storage" href="/docs/concepts/blob-storage" />
</Cards>
