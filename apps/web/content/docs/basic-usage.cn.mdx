---
title: 基本用法
description: AgentStart 入门
---

AgentStart 使构建具有持久化对话、工具执行和类型安全客户端集成的 AI 智能体变得容易。

## 创建智能体

智能体由模型、指令和工具组成。这是一个基本示例：

```ts title="lib/agent.ts"
import { createOpenRouter } from "@openrouter/ai-sdk-provider";
import { Agent, innerTools, osTools } from "agentstart/agent";

const openrouter = createOpenRouter({
  apiKey: process.env.MODEL_PROVIDER_API_KEY!,
});

const agent = new Agent({
  model: openrouter("x-ai/grok-4-fast"),
  instructions: "你是一个乐于助人的编程助手。",
  tools: {
    ...innerTools,  // 任务管理工具
    ...osTools,     // 文件和 Shell 工具
  },
});
```

### 可用工具

**innerTools** 提供任务管理：
- `todoRead` - 读取当前任务列表
- `todoWrite` - 更新任务列表

**osTools** 提供文件系统和 Shell 操作：
- `bash` - 执行 Shell 命令
- `read` - 读取文件内容
- `write` - 写入文件
- `update` - 更新文件部分
- `glob` - 按模式搜索文件
- `grep` - 搜索文件内容
- `ls` - 列出目录内容

## 启动智能体运行时

使用 `agentStart()` 包装您的智能体以创建 API 处理器：

```ts title="lib/agent.ts"
import { agentStart } from "agentstart";
import { drizzleAdapter } from "agentstart/db";
import { db } from "@/db";
import * as schema from "@/db/schema";

export const start = agentStart({
  agent,
  memory: drizzleAdapter(db, {
    provider: "pg",
    schema: {
      thread: schema.threadsTable,
      message: schema.messagesTable,
    },
  }),
  appName: "my-app",
});
```

### 配置选项

<Tabs items={["memory", "basePath", "middleware"]}>
  <Tab value="memory">
    用于持久化对话的数据库适配器：
    
    ```ts
    import { drizzleAdapter } from "agentstart/db";
    import { prismaAdapter } from "agentstart/db";
    import { kyselyAdapter } from "agentstart/db";
    import { mongodbAdapter } from "agentstart/db";
    
    // 使用 Drizzle
    memory: drizzleAdapter(db, { provider: "pg", schema })
    
    // 使用 Prisma
    memory: prismaAdapter(prisma, { provider: "postgresql" })
    
    // 使用 Kysely
    memory: kyselyAdapter(db)
    
    // 使用 MongoDB
    memory: mongodbAdapter(db)
    ```
  </Tab>
  
  <Tab value="basePath">
    自定义 API 基础路径（默认：`/api/agent`）：
    
    ```ts
    export const start = agentStart({
      agent,
      memory,
      basePath: "/api/my-agent",
    });
    ```
  </Tab>
  
  <Tab value="middleware">
    添加用于日志记录、身份验证等的自定义中间件：
    
    ```ts
    import { os } from "@orpc/server";
    
    const loggingMiddleware = os.middleware(async ({ next }) => {
      console.log("请求开始");
      const result = await next();
      console.log("请求完成");
      return result;
    });
    
    export const start = agentStart({
      agent,
      memory,
      middleware: [loggingMiddleware],
    });
    ```
  </Tab>
</Tabs>

## 使用客户端

创建客户端以与您的智能体交互：

```ts title="lib/agent-client.ts"
import { createAgentClient } from "agentstart/client";

export const { client, useThread } = createAgentClient({
  baseURL: "http://localhost:3000", // 如果在同一域名则可选
});
```

### 访问线程状态

使用 `useThread` hook 在 React 组件中同步线程状态：

```tsx title="app/thread/[threadId]/page.tsx"
"use client";

import { useThread, useAgentStore } from "@/lib/agent-client";
import { useParams } from "next/navigation";

export default function ThreadPage() {
  const { threadId } = useParams<{ threadId: string }>();
  
  // 同步线程状态
  useThread(threadId);
  
  // 访问智能体状态
  const messages = useAgentStore((state) => state.messages, threadId);
  const sendMessage = useAgentStore((state) => state.sendMessage, threadId);
  
  const handleSend = async (content: string) => {
    await sendMessage({ content });
  };
  
  return (
    <div>
      {messages.map((message) => (
        <div key={message.id}>
          <strong>{message.role}:</strong> {message.content}
        </div>
      ))}
      <input
        onKeyDown={(e) => {
          if (e.key === "Enter") {
            handleSend(e.currentTarget.value);
            e.currentTarget.value = "";
          }
        }}
      />
    </div>
  );
}
```

### Agent Store API

智能体存储提供对对话状态的访问：

```tsx
import { useAgentStore } from "@/lib/agent-client";

// 获取消息
const messages = useAgentStore((state) => state.messages, threadId);

// 获取加载状态
const isLoading = useAgentStore((state) => state.isLoading, threadId);

// 发送消息
const sendMessage = useAgentStore((state) => state.sendMessage, threadId);

// 获取线程元数据
const thread = useAgentStore((state) => state.thread, threadId);
```

## 添加自定义工具

使用自定义工具扩展您的智能体：

```ts
import { z } from "zod";

const weatherTool = {
  description: "获取某个位置的当前天气",
  parameters: z.object({
    location: z.string().describe("城市名称"),
    units: z.enum(["celsius", "fahrenheit"]).default("celsius"),
  }),
  execute: async ({ location, units }) => {
    const response = await fetch(
      `https://api.weather.com/current?location=${location}&units=${units}`
    );
    return await response.json();
  },
};

const agent = new Agent({
  model,
  instructions: "你是一个拥有天气信息的乐于助人的助手。",
  tools: {
    ...osTools,
    getWeather: weatherTool,
  },
});
```

### 工具最佳实践

<Callout type="warn">
始终在工具中验证输入并处理错误。切勿在工具响应中暴露敏感数据。
</Callout>

1. **清晰的描述**：编写详细的描述，以便模型知道何时使用工具
2. **模式验证**：使用 Zod 验证所有参数
3. **错误处理**：返回有用的错误消息
4. **类型安全**：使用 TypeScript 获得更好的 IDE 支持

## 服务端用法

在服务器上访问智能体功能：

```ts title="app/api/threads/route.ts"
import { start } from "@/lib/agent";

export async function GET() {
  // 访问服务器 API
  const threads = await start.api.thread.list();
  
  return Response.json(threads);
}
```

<Callout type="info">
`start.api` 对象提供对服务器上所有智能体操作的类型安全访问。
</Callout>

## 身份验证

为您的智能体添加用户身份验证：

```ts title="lib/agent.ts"
export const start = agentStart({
  agent,
  memory,
  getUserId: async (headers) => {
    // 从 auth header 提取用户 ID
    const token = headers.get("authorization");
    if (!token) throw new Error("未授权");
    const user = await verifyToken(token);
    return user.id;
  },
});
```

## 下一步

<Cards>
  <Card title="核心概念" href="/cn/docs/concepts/core-concepts" />
  <Card title="工具" href="/cn/docs/tools" />
  <Card title="数据库适配器" href="/cn/docs/adapters/drizzle" />
  <Card title="框架集成" href="/cn/docs/integrations/next" />
</Cards>
