---
title: Basic Usage
description: Getting started with AgentStart
---

AgentStart makes it easy to build AI agents with persistent conversations, tool execution, and type-safe client integration.

## Creating an Agent

An agent consists of a model, instructions, and tools. Here's a basic example:

```ts title="lib/agent.ts"
import { createOpenRouter } from "@openrouter/ai-sdk-provider";
import { Agent, agentTools, osTools } from "agentstart/agent";

const openrouter = createOpenRouter({
  apiKey: process.env.MODEL_PROVIDER_API_KEY!,
});

const agent = new Agent({
  model: openrouter("x-ai/grok-4-fast"),
  instructions: "You are a helpful coding assistant.",
  tools: {
    ...agentTools, // Task management tools
    ...osTools,    // File system and shell operations
  },
});
```

### Available Tools

**agentTools** provides task management:
- `todoRead` - Read the current task list
- `todoWrite` - Update task list with new tasks

**osTools** provides file system and shell operations:
- `bash` - Execute shell commands
- `read` - Read file contents
- `write` - Write to files
- `edit` - Update file sections
- `glob` - Search files by pattern
- `grep` - Search file contents
- `ls` - List directory contents

You can import and use them together or separately:

```ts
import { Agent, agentTools, osTools } from "agentstart/agent";

// Use both tool sets
const agent = new Agent({
  model,
  instructions: "You are a helpful coding assistant.",
  tools: {
    ...agentTools,
    ...osTools,
  },
});

// Or use only task management tools
const agent = new Agent({
  model,
  instructions: "You are a task-focused assistant.",
  tools: {
    ...agentTools,
  },
});
```

## Starting the Agent Runtime

Wrap your agent with `agentStart()` to create an API handler:

```ts title="lib/agent.ts"
import { agentStart } from "agentstart";
import { drizzleMemoryAdapter } from "agentstart/memory";
import { db } from "@/db";
import * as schema from "@/db/schema";

export const start = agentStart({
  agent,
  memory: drizzleMemoryAdapter(db, {
    provider: "postgresql",
    schema,
  }),
  appName: "my-app",
});
```

### Configuration Options

<Tabs items={["memory", "basePath", "middleware"]}>
  <Tab value="memory">
    Database adapter for persisting conversations:

    ```ts
    import { drizzleMemoryAdapter } from "agentstart/memory";
    import { prismaMemoryAdapter } from "agentstart/memory";
    import { kyselyMemoryAdapter } from "agentstart/memory";
    import { mongodbMemoryAdapter } from "agentstart/memory";

    // Use Drizzle
    memory: drizzleMemoryAdapter(db, { provider: "postgresql", schema })

    // Use Prisma
    memory: prismaMemoryAdapter(prisma, { provider: "postgresql" })

    // Use Kysely
    memory: kyselyMemoryAdapter(db)

    // Use MongoDB
    memory: mongodbMemoryAdapter(db)
    ```
  </Tab>
  
  <Tab value="basePath">
    Customize the API base path (default: `/api/agent`):
    
    ```ts
    export const start = agentStart({
      agent,
      memory,
      basePath: "/api/my-agent",
    });
    ```
  </Tab>
  
  <Tab value="middleware">
    Add custom middleware for logging, authentication, etc:
    
    ```ts
    import { os } from "@orpc/server";
    
    const loggingMiddleware = os.middleware(async ({ next }) => {
      console.log("Request started");
      const result = await next();
      console.log("Request completed");
      return result;
    });
    
    export const start = agentStart({
      agent,
      memory,
      middleware: [loggingMiddleware],
    });
    ```
  </Tab>
</Tabs>

## Using the Client

Create a client to interact with your agent:

```ts title="lib/agent-client.ts"
import {
  createAgentClient,
  useAgentStore,
  useThreadStore,
} from "agentstart/client";

export const { client, useThread } = createAgentClient();

export { useAgentStore, useThreadStore };
```

### Accessing Thread State

Use the `useThread` hook to sync thread state in your React components:

```tsx title="app/thread/[threadId]/page.tsx"
"use client";

import { useThread, useAgentStore } from "@/lib/agent-client";
import { useParams } from "next/navigation";

export default function ThreadPage() {
  const { threadId } = useParams<{ threadId: string }>();

  // Sync thread state
  useThread(threadId);

  // Access agent state
  const messages = useAgentStore((state) => state.messages, threadId);
  const status = useAgentStore((state) => state.status, threadId);
  const sendMessage = useAgentStore((state) => state.sendMessage, threadId);

  const handleSend = async (text: string) => {
    await sendMessage({ text });
  };

  return (
    <div>
      {messages.map((message) => {
        const text = message.parts?.find(
          (part): part is { type: "text"; text: string } => part.type === "text",
        )?.text;

        return (
          <div key={message.id}>
            <strong>{message.role}:</strong> {text ?? ""}
          </div>
        );
      })}
      {status === "streaming" && <span>Receiving responseâ€¦</span>}
      <input
        onKeyDown={(e) => {
          if (e.key === "Enter") {
            handleSend(e.currentTarget.value);
            e.currentTarget.value = "";
          }
        }}
      />
    </div>
  );
}
```

Need metadata like the current thread title? Use `useThreadStore((state) => state.getThread(threadId))` alongside `useThread` to stay in sync.

### Agent & Thread Stores

The agent store provides conversation state helpers, and the thread store exposes the latest metadata for each thread:

```tsx
import { useAgentStore, useThreadStore } from "@/lib/agent-client";

// Get messages
const messages = useAgentStore((state) => state.messages, threadId);

// Get status ("ready" | "streaming" | "error")
const status = useAgentStore((state) => state.status, threadId);

// Send message
const sendMessage = useAgentStore((state) => state.sendMessage, threadId);

// Get thread metadata
const thread = useThreadStore((state) => state.getThread(threadId));
```

## Adding Custom Tools

Extend your agent with custom tools:

```ts
import { z } from "zod";

const weatherTool = {
  description: "Get current weather for a location",
  parameters: z.object({
    location: z.string().describe("City name"),
    units: z.enum(["celsius", "fahrenheit"]).default("celsius"),
  }),
  execute: async ({ location, units }) => {
    const response = await fetch(
      `https://api.weather.com/current?location=${location}&units=${units}`
    );
    return await response.json();
  },
};

const agent = new Agent({
  model,
  instructions: "You are a helpful assistant with weather information.",
  tools: {
    ...agentTools,
    getWeather: weatherTool,
  },
});
```

### Tool Best Practices

<Callout type="warn">
Always validate inputs and handle errors in your tools. Never expose sensitive data in tool responses.
</Callout>

1. **Clear Descriptions**: Write detailed descriptions so the model knows when to use the tool
2. **Schema Validation**: Use Zod to validate all parameters
3. **Error Handling**: Return helpful error messages
4. **Type Safety**: Use TypeScript for better IDE support

## Server-Side Usage

Access agent functionality on the server:

```ts title="app/api/threads/route.ts"
import { start } from "@/lib/agent"; // path to your agent file

export async function GET() {
  // Access the server API
  const { threads } = await start.api.thread.list();

  return Response.json(threads);
}
```

<Callout type="info">
The `start.api` object provides type-safe access to all agent operations on the server.
</Callout>

## Authentication

Add user authentication to your agent:

```ts title="lib/agent.ts"
export const start = agentStart({
  agent,
  memory,
  getUserId: async (headers) => {
    // Extract user ID from auth header
    const token = headers.get("authorization");
    if (!token) throw new Error("Unauthorized");
    const user = await verifyToken(token);
    return user.id;
  },
});
```

## Next Steps

<Cards>
  <Card title="Database" href="/docs/concepts/database" />
  <Card title="Tools" href="/docs/concepts/tools" />
  <Card title="Drizzle Adapter" href="/docs/databases/drizzle" />
  <Card title="Next.js Integration" href="/docs/integrations/next" />
</Cards>
