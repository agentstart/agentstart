{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "message-part-view",
  "type": "registry:component",
  "title": "AgentStart Message Part View",
  "description": "Route different tool and content types to their specific UI components. Dispatches tool parts to specialized renderers for bash, read, write, and other tools.",
  "dependencies": [
    "@agentstart/utils",
    "@phosphor-icons/react",
    "agentstart",
    "ai",
    "react",
    "react-fast-compare"
  ],
  "registryDependencies": [
    "@coss/tooltip"
  ],
  "files": [
    {
      "path": "src/registry/agentstart/tools/message-part-view.tsx",
      "content": "/* agent-frontmatter:start\nAGENT: Message part view orchestrator\nPURPOSE: Route different tool and content types to their specific UI components\nUSAGE: <MessagePart part={part} isStreaming={isStreaming} />\nEXPORTS: MessagePart\nFEATURES:\n  - Dispatches tool parts to specialized renderers (bash, read, write, etc.)\n  - Renders text content with markdown support\n  - Handles reasoning blocks with collapsible UI\n  - Supports all AgentStart tool visualizations\nSEARCHABLE: message view, tool renderer, part dispatcher, ui orchestrator\nagent-frontmatter:end */\n\nimport type { AgentStartToolSet, BaseMessagePart } from \"agentstart/agent\";\nimport { memo } from \"react\";\nimport isEqual from \"react-fast-compare\";\nimport { Response } from \"../response\";\nimport { Bash } from \"./bash\";\nimport { EditFile } from \"./edit\";\nimport { Glob } from \"./glob\";\nimport { Grep } from \"./grep\";\nimport { Ls } from \"./ls\";\nimport { ReadFile } from \"./read\";\nimport {\n  Reasoning as BaseReasoning,\n  getThinkingMessage,\n  ReasoningContent,\n  ReasoningTrigger,\n} from \"./reasoning\";\nimport { Todo } from \"./todo\";\nimport { WriteFile } from \"./write\";\n\n// ========= Add your custom tool types here =========\n// To add new tools, simply add them to the type below\n// Example:\n// type ExtendedToolSet = AgentStartToolSet & {\n//   myCustomTool?: any;  // Add other custom tools\n// }\ntype ExtendedToolSet = AgentStartToolSet;\n// ================================================\n\ninterface Props {\n  part: BaseMessagePart<ExtendedToolSet>;\n  isStreaming: boolean;\n}\n\nexport const MessagePart = memo<Props>(({ part, isStreaming }) => {\n  switch (part.type) {\n    case \"tool-read\": {\n      return <ReadFile part={part} />;\n    }\n    case \"tool-write\":\n      return <WriteFile part={part} />;\n    case \"tool-edit\":\n      return <EditFile part={part} />;\n    case \"tool-bash\":\n      return <Bash part={part} />;\n    case \"tool-glob\":\n      return <Glob part={part} />;\n    case \"tool-grep\":\n      return <Grep part={part} />;\n    case \"tool-ls\":\n      return <Ls part={part} />;\n    case \"tool-todoRead\":\n    case \"tool-todoWrite\":\n      return <Todo part={part} />;\n\n    case \"reasoning\":\n      return (\n        <Reasoning\n          className=\"w-full\"\n          isStreaming={isStreaming}\n          text={part.text}\n        />\n      );\n    case \"text\":\n      return <Response>{part.text}</Response>;\n    default:\n      return null;\n  }\n}, isEqual);\n\nfunction Reasoning({\n  className,\n  text,\n  isStreaming,\n}: {\n  className?: string;\n  text: string;\n  isStreaming: boolean;\n}) {\n  return (\n    <BaseReasoning\n      className={className}\n      isStreaming={isStreaming}\n      defaultOpen={false}\n    >\n      <ReasoningTrigger>{getThinkingMessage(isStreaming)}</ReasoningTrigger>\n      <ReasoningContent>{text}</ReasoningContent>\n    </BaseReasoning>\n  );\n}\n",
      "type": "registry:component",
      "target": "components/agent/tools/message-part-view.tsx"
    },
    {
      "path": "src/registry/agentstart/tools/bash.tsx",
      "content": "/* agent-frontmatter:start\nAGENT: Bash tool UI component\nPURPOSE: Display shell command execution results with stdout/stderr output\nUSAGE: <Bash part={toolPart} />\nEXPORTS: Bash, BashProps\nFEATURES:\n  - Shows executed command with description\n  - Renders stdout and stderr with syntax highlighting\n  - Displays execution duration and exit code\n  - Distinguishes between success and error states\nSEARCHABLE: bash tool, shell command ui, terminal output view\nagent-frontmatter:end */\n\nimport { CommandIcon } from \"@phosphor-icons/react\";\nimport type { Tools } from \"agentstart/agent\";\nimport type { InferUITools, ToolUIPart } from \"ai\";\nimport { useMemo } from \"react\";\nimport {\n  Tooltip,\n  TooltipContent,\n  TooltipTrigger,\n} from \"@/components/ui/tooltip\";\nimport { CodeBlock } from \"../code-block\";\nimport { Steps, StepsContent, StepsItem, StepsTrigger } from \"../steps\";\n\nexport interface BashProps {\n  part: ToolUIPart<InferUITools<Pick<Tools, \"bash\">>>;\n}\n\nexport function Bash({ part: { state, input, output } }: BashProps) {\n  const hasOutput = output?.metadata?.stdout || output?.metadata?.stderr;\n  const formatDuration = (ms?: number) => {\n    if (!ms) return \"\";\n    return ms < 1000 ? `${ms}ms` : `${(ms / 1000).toFixed(2)}s`;\n  };\n  const isLoading = [\"input-streaming\", \"input-available\"].includes(state);\n\n  const title = useMemo(() => {\n    if (!input?.command) return <span>Ran command</span>;\n    return (\n      <div className=\"flex w-full items-center gap-2 overflow-hidden\">\n        Ran command:\n        <Tooltip>\n          <TooltipTrigger\n            render={\n              <span className=\"flex-1 truncate text-left font-mono text-foreground\">\n                {input?.command}\n              </span>\n            }\n          />\n          <TooltipContent align=\"start\">\n            <div className=\"flex flex-col gap-1\">\n              {input?.description && (\n                <span className=\"text-muted-foreground text-xs\">\n                  {input.description}\n                </span>\n              )}\n\n              {/* Exit code and duration */}\n              {state === \"output-available\" && output && (\n                <div className=\"flex items-center gap-4 text-muted-foreground text-xs\">\n                  {output.metadata?.exitCode !== undefined && (\n                    <span\n                      className={\n                        output.metadata.exitCode === 0\n                          ? undefined\n                          : \"text-yellow-600\"\n                      }\n                    >\n                      Exit code: {output.metadata.exitCode}\n                    </span>\n                  )}\n                  {output.metadata?.duration && (\n                    <span>\n                      Duration: {formatDuration(output.metadata.duration)}\n                    </span>\n                  )}\n                  {/* {output.metadata?.commitHash && (\n            <CommitHash hash={output.metadata.commitHash} />\n          )} */}\n                </div>\n              )}\n            </div>\n          </TooltipContent>\n        </Tooltip>\n      </div>\n    );\n  }, [input?.command, input?.description, output, state]);\n\n  return (\n    <Steps data-tool-bash>\n      <StepsTrigger\n        loading={isLoading}\n        error={output?.status === \"error\" || Boolean(output?.error)}\n        leftIcon={<CommandIcon weight=\"duotone\" className=\"size-4\" />}\n      >\n        {title}\n      </StepsTrigger>\n      <StepsContent>\n        <StepsItem>\n          <div className=\"space-x-2\">\n            <span className=\"text-sm\">$</span>\n            <span className=\"font-mono text-foreground text-sm\">\n              {input?.command}\n            </span>\n          </div>\n        </StepsItem>\n\n        {/* Status indicators */}\n        {isLoading && (\n          <StepsItem className=\"flex items-center gap-2 text-muted-foreground text-xs\">\n            <span>Executing command...</span>\n          </StepsItem>\n        )}\n\n        {/* Standard output */}\n        {output?.metadata?.stdout && (\n          <StepsItem>\n            <CodeBlock code={output.metadata.stdout} language=\"bash\" />\n          </StepsItem>\n        )}\n\n        {/* No output message */}\n        {state === \"output-available\" && output && !hasOutput && (\n          <StepsItem>Command executed successfully (no output)</StepsItem>\n        )}\n\n        {/* Standard error */}\n        {output?.metadata?.stderr && (\n          <StepsItem>\n            <CodeBlock\n              code={output.metadata.stderr}\n              language=\"bash\"\n              className=\"border-red-200 text-xs dark:border-red-900\"\n            />\n          </StepsItem>\n        )}\n      </StepsContent>\n    </Steps>\n  );\n}\n",
      "type": "registry:component",
      "target": "components/agent/tools/bash.tsx"
    },
    {
      "path": "src/registry/agentstart/tools/glob.tsx",
      "content": "/* agent-frontmatter:start\nAGENT: Glob tool UI component\nPURPOSE: Display file pattern matching results from glob tool\nUSAGE: <Glob part={toolPart} />\nEXPORTS: Glob, GlobProps\nFEATURES:\n  - Renders matched file and directory paths\n  - Color-coded icons for files vs directories\n  - Shows pattern used and match count\n  - Highlights filename vs directory path distinction\nSEARCHABLE: glob tool, file pattern match ui, file search results\nagent-frontmatter:end */\n\nimport {\n  FileIcon,\n  FileMagnifyingGlassIcon,\n  FolderIcon,\n} from \"@phosphor-icons/react\";\nimport type { Tools } from \"agentstart/agent\";\nimport type { InferUITools, ToolUIPart } from \"ai\";\nimport { useCallback, useMemo } from \"react\";\nimport { Shimmer } from \"../shimmer\";\nimport { Steps, StepsContent, StepsItem, StepsTrigger } from \"../steps\";\n\nexport interface GlobProps {\n  part: ToolUIPart<InferUITools<Pick<Tools, \"glob\">>>;\n}\n\nexport function Glob({ part: { state, input, output } }: GlobProps) {\n  const isLoading = [\"input-streaming\", \"input-available\"].includes(state);\n\n  const renderMatch = useCallback((match: string) => {\n    const isDirectory = match.endsWith(\"/\");\n    const cleanPath = isDirectory ? match.slice(0, -1) : match;\n    const parts = cleanPath.split(\"/\");\n    const fileName = parts[parts.length - 1];\n    const dirPath = parts.slice(0, -1).join(\"/\");\n\n    return (\n      <div className=\"flex items-center gap-2 py-0.5 text-xs\">\n        {isDirectory ? (\n          <FolderIcon className=\"size-4\" weight=\"duotone\" />\n        ) : (\n          <FileIcon className=\"size-4\" weight=\"duotone\" />\n        )}\n        <span>\n          {dirPath && <span className=\"text-muted-foreground\">{dirPath}/</span>}\n          <span className=\"font-medium\">{fileName}</span>\n        </span>\n      </div>\n    );\n  }, []);\n\n  const results = useMemo(() => {\n    if (!Array.isArray(output?.metadata?.matches)) return null;\n\n    const matches = output.metadata.matches as string[];\n    const totalMatches =\n      typeof output.metadata?.count === \"number\"\n        ? output.metadata.count\n        : matches.length;\n\n    return (\n      <div className=\"flex flex-col gap-2\">\n        {/* Pattern and path */}\n        <div className=\"flex flex-col gap-1\">\n          <div className=\"text-xs\">\n            <span className=\"text-muted-foreground\">Pattern: </span>\n            <code className=\"rounded bg-muted/50 px-1 py-0.5 font-mono\">\n              {input?.pattern}\n            </code>\n          </div>\n          {input?.path && (\n            <div className=\"text-xs\">\n              <span className=\"text-muted-foreground\">In: </span>\n              <code className=\"font-mono\">{input.path}</code>\n            </div>\n          )}\n        </div>\n\n        {/* Results */}\n        <div className=\"mt-1\">\n          <div className=\"mb-1 text-muted-foreground text-xs\">\n            Found {totalMatches} match{totalMatches !== 1 ? \"es\" : \"\"}\n          </div>\n          {matches.length > 0 ? (\n            <div className=\"max-h-[300px] overflow-y-auto border-muted border-l-2 pl-2\">\n              {matches.slice(0, 100).map((match, index) => (\n                <div key={`${match}-${index}`}>{renderMatch(match)}</div>\n              ))}\n              {matches.length > 100 && (\n                <div className=\"mt-2 text-muted-foreground text-xs\">\n                  ... and {matches.length - 100} more\n                </div>\n              )}\n            </div>\n          ) : (\n            <span className=\"text-muted-foreground text-xs italic\">\n              No files found matching this pattern\n            </span>\n          )}\n        </div>\n      </div>\n    );\n  }, [input?.path, input?.pattern, output?.metadata, renderMatch]);\n\n  return (\n    <Steps data-tool-glob>\n      <StepsTrigger\n        leftIcon={\n          <FileMagnifyingGlassIcon weight=\"duotone\" className=\"size-4\" />\n        }\n        loading={isLoading}\n        error={output?.status === \"error\" || Boolean(output?.error)}\n      >\n        <div className=\"flex items-center gap-2\">\n          <span>Glob pattern: </span>\n          <code className=\"rounded bg-muted/50 px-1 py-0.5 font-mono text-xs\">\n            {input?.pattern}\n          </code>\n        </div>\n      </StepsTrigger>\n      <StepsContent>\n        {isLoading && (\n          <StepsItem className=\"flex items-center gap-2 text-muted-foreground text-xs\">\n            <Shimmer>Searching files...</Shimmer>\n          </StepsItem>\n        )}\n        {results && <StepsItem>{results}</StepsItem>}\n        {output?.error?.message && (\n          <StepsItem className=\"text-red-600 text-xs\">\n            {output.error.message}\n          </StepsItem>\n        )}\n      </StepsContent>\n    </Steps>\n  );\n}\n",
      "type": "registry:component",
      "target": "components/agent/tools/glob.tsx"
    },
    {
      "path": "src/registry/agentstart/tools/grep.tsx",
      "content": "/* agent-frontmatter:start\nAGENT: Grep tool UI component\nPURPOSE: Display code search results from grep tool with syntax highlighting\nUSAGE: <Grep part={toolPart} />\nEXPORTS: Grep, GrepProps\nFEATURES:\n  - Shows search pattern and matched content\n  - Supports multiple output modes (content/files/count)\n  - Syntax highlighting for matched code lines\n  - Displays file paths and line numbers with matches\nSEARCHABLE: grep tool, code search ui, content search results\nagent-frontmatter:end */\n\nimport { FileIcon, HashIcon } from \"@phosphor-icons/react\";\nimport type { Tools } from \"agentstart/agent\";\nimport type { InferUITools, ToolUIPart } from \"ai\";\nimport { CodeBlock } from \"../code-block\";\nimport { Shimmer } from \"../shimmer\";\nimport { Steps, StepsContent, StepsItem, StepsTrigger } from \"../steps\";\n\nexport interface GrepProps {\n  part: ToolUIPart<InferUITools<Pick<Tools, \"grep\">>>;\n}\n\nexport function Grep({ part: { state, input, output } }: GrepProps) {\n  const isLoading = [\"input-streaming\", \"input-available\"].includes(state);\n\n  const getOutputModeLabel = () => {\n    switch (input?.outputMode) {\n      case \"content\":\n        return \"Matching Lines\";\n      case \"count\":\n        return \"Match Counts\";\n      // case \"files_with_matches\":\n      default:\n        return \"Matching Files\";\n    }\n  };\n\n  const renderFilesOutput = () => {\n    const files = Array.isArray(output?.metadata?.files)\n      ? (output.metadata.files as string[])\n      : [];\n    if (files.length === 0) {\n      return (\n        <span className=\"text-muted-foreground text-xs italic\">\n          No files found with matches\n        </span>\n      );\n    }\n\n    const maxFiles = 100;\n    const displayFiles = files.slice(0, maxFiles);\n    const hasMore = files.length > maxFiles;\n\n    return (\n      <div className=\"mt-2\">\n        <div className=\"mb-1 text-muted-foreground text-xs\">\n          Found in {output?.metadata?.fileCount ?? files.length} file\n          {(output?.metadata?.fileCount ?? files.length) !== 1 && \"s\"}\n        </div>\n        <div className=\"max-h-[300px] overflow-y-auto border-muted border-l-2 pl-2\">\n          {displayFiles.map((file, index) => (\n            <div\n              key={`${file}-${index}`}\n              className=\"flex items-center gap-2 py-0.5 text-xs\"\n            >\n              <FileIcon className=\"size-4\" weight=\"duotone\" />\n              <span className=\"font-mono\">{file}</span>\n            </div>\n          ))}\n          {hasMore && (\n            <div className=\"mt-2 text-muted-foreground text-xs\">\n              {`// ... and ${files.length - maxFiles} more`}\n            </div>\n          )}\n        </div>\n      </div>\n    );\n  };\n\n  const renderCountsOutput = () => {\n    const counts = Array.isArray(output?.metadata?.counts)\n      ? (output.metadata.counts as Array<{ filename: string; count: number }>)\n      : [];\n    if (counts.length === 0) {\n      return (\n        <span className=\"text-muted-foreground text-xs italic\">\n          No matches found\n        </span>\n      );\n    }\n\n    return (\n      <div className=\"mt-2\">\n        <div className=\"mb-1 text-muted-foreground text-xs\">\n          Total: {output?.metadata?.totalMatches || 0} match\n          {(output?.metadata?.totalMatches || 0) !== 1 && \"es\"} in{\" \"}\n          {counts.length} file{counts.length !== 1 && \"s\"}\n        </div>\n        <div className=\"max-h-[300px] space-y-0.5 overflow-y-auto font-mono text-xs\">\n          {counts.map((item, index) => (\n            <div\n              key={`${item.filename}-${index}`}\n              className=\"flex items-center gap-2 rounded px-1 py-0.5 hover:bg-muted/50\"\n            >\n              <HashIcon className=\"size-4\" weight=\"duotone\" />\n              <span className=\"w-12 text-right text-blue-600\">\n                {item.count}\n              </span>\n              <span>{item.filename}</span>\n            </div>\n          ))}\n        </div>\n      </div>\n    );\n  };\n\n  const renderContentOutput = () => {\n    const matches = Array.isArray(output?.metadata?.matches)\n      ? (output.metadata.matches as string[])\n      : [];\n    if (matches.length === 0) {\n      return (\n        <span className=\"text-muted-foreground text-xs italic\">\n          No matching lines found\n        </span>\n      );\n    }\n\n    // Join all matches into a single string for the code block\n    const content = matches.join(\"\\n\");\n\n    return (\n      <div className=\"mt-2\">\n        <div className=\"mb-1 text-muted-foreground text-xs\">\n          Found {output?.metadata?.matchCount || 0} match\n          {(output?.metadata?.matchCount || 0) !== 1 && \"es\"} in{\" \"}\n          {output?.metadata?.fileCount || 0} file\n          {(output?.metadata?.fileCount || 0) !== 1 && \"s\"}\n        </div>\n        <CodeBlock code={content} language=\"markdown\" />\n      </div>\n    );\n  };\n\n  const renderResults = () => {\n    if (!output) return null;\n\n    return (\n      <div className=\"flex flex-col gap-2\">\n        {/* Pattern and options */}\n        <div className=\"flex flex-col gap-1\">\n          <div className=\"text-xs\">\n            <span className=\"text-muted-foreground\">Pattern: </span>\n            <code className=\"rounded bg-muted/50 px-1 py-0.5 font-mono\">\n              {input?.pattern}\n            </code>\n          </div>\n          {input?.path && (\n            <div className=\"text-xs\">\n              <span className=\"text-muted-foreground\">In: </span>\n              <code className=\"font-mono\">{input.path}</code>\n            </div>\n          )}\n          {input?.outputMode && (\n            <div className=\"text-xs\">\n              <span className=\"text-muted-foreground\">Mode: </span>\n              <span>{getOutputModeLabel()}</span>\n            </div>\n          )}\n        </div>\n\n        {/* Results based on output mode */}\n        {input?.outputMode === \"files_with_matches\" || !input?.outputMode\n          ? renderFilesOutput()\n          : input?.outputMode === \"count\"\n            ? renderCountsOutput()\n            : renderContentOutput()}\n      </div>\n    );\n  };\n\n  return (\n    <Steps data-tool-grep>\n      <StepsTrigger\n        leftIcon={<HashIcon weight=\"duotone\" className=\"size-4\" />}\n        loading={isLoading}\n        error={output?.status === \"error\" || Boolean(output?.error)}\n      >\n        <div className=\"flex items-center gap-2\">\n          <span>Search pattern: </span>\n          <code className=\"rounded bg-muted/50 px-1 py-0.5 font-mono text-xs\">\n            {input?.pattern}\n          </code>\n        </div>\n      </StepsTrigger>\n      <StepsContent>\n        {isLoading && (\n          <StepsItem className=\"flex items-center gap-2 text-muted-foreground text-xs\">\n            <Shimmer>Searching code...</Shimmer>\n          </StepsItem>\n        )}\n        <StepsItem>{renderResults()}</StepsItem>\n        {output?.error?.message && (\n          <StepsItem className=\"text-red-600 text-xs\">\n            {output.error.message}\n          </StepsItem>\n        )}\n      </StepsContent>\n    </Steps>\n  );\n}\n",
      "type": "registry:component",
      "target": "components/agent/tools/grep.tsx"
    },
    {
      "path": "src/registry/agentstart/tools/ls.tsx",
      "content": "/* agent-frontmatter:start\nAGENT: Ls tool UI component\nPURPOSE: Display directory listings from the ls tool with file metadata\nUSAGE: <Ls part={toolPart} />\nEXPORTS: Ls, LsProps\nFEATURES:\n  - Renders file/directory/symlink entries with appropriate icons\n  - Shows file sizes and modification dates\n  - Distinguishes file types with color-coded icons\n  - Displays tool execution state (pending/success/error)\nSEARCHABLE: ls tool, directory listing, file browser ui\nagent-frontmatter:end */\n\nimport { formatDate, formatSize } from \"@agentstart/utils\";\nimport { FileIcon, FolderIcon, LinkIcon } from \"@phosphor-icons/react\";\nimport type { Tools } from \"agentstart/agent\";\nimport type { InferUITools, ToolUIPart } from \"ai\";\nimport { useCallback, useMemo } from \"react\";\nimport { Shimmer } from \"../shimmer\";\nimport { Steps, StepsContent, StepsItem, StepsTrigger } from \"../steps\";\n\nexport interface LsProps {\n  part: ToolUIPart<InferUITools<Pick<Tools, \"ls\">>>;\n}\n\nexport function Ls({ part: { state, input, output } }: LsProps) {\n  const isLoading = [\"input-streaming\", \"input-available\"].includes(state);\n\n  const getIcon = useCallback((entryType: \"file\" | \"directory\" | \"symlink\") => {\n    switch (entryType) {\n      case \"directory\":\n        return <FolderIcon className=\"size-4\" weight=\"duotone\" />;\n      case \"symlink\":\n        return <LinkIcon className=\"size-4\" weight=\"duotone\" />;\n      default:\n        return <FileIcon className=\"size-4\" weight=\"duotone\" />;\n    }\n  }, []);\n\n  const entries = useMemo(() => {\n    if (!Array.isArray(output?.metadata?.entries)) return null;\n    type LsEntry = {\n      type: \"file\" | \"directory\" | \"symlink\";\n      name: string;\n      size: number;\n      modifiedTime: number;\n    };\n    const entries = output.metadata.entries as LsEntry[];\n\n    return (\n      <div>\n        {entries.length > 0 ? (\n          <div className=\"space-y-0.5 font-mono text-xs\">\n            {entries.map((entry, index) => (\n              <div\n                key={`${entry.name}-${index}`}\n                className=\"flex items-center gap-2 rounded px-1 py-0.5 hover:bg-muted/50\"\n              >\n                {getIcon(entry.type)}\n                <span className=\"w-12 text-right text-muted-foreground\">\n                  {entry.type === \"directory\" ? \"-\" : formatSize(entry.size)}\n                </span>\n                <span className=\"text-muted-foreground\">\n                  {formatDate(entry.modifiedTime)}\n                </span>\n                <span\n                  className={\n                    entry.type === \"directory\"\n                      ? \"font-medium text-muted-foreground\"\n                      : \"text-foreground\"\n                  }\n                >\n                  {entry.name}\n                  {entry.type === \"directory\" && \"/\"}\n                  {entry.type === \"symlink\" && \" →\"}\n                </span>\n              </div>\n            ))}\n          </div>\n        ) : (\n          <span className=\"text-muted-foreground text-xs italic\">\n            Directory is empty\n          </span>\n        )}\n      </div>\n    );\n  }, [getIcon, output?.metadata]);\n\n  return (\n    <Steps data-tool-ls>\n      <StepsTrigger\n        leftIcon={<FolderIcon weight=\"duotone\" className=\"size-4\" />}\n        loading={isLoading}\n        error={output?.status === \"error\" || Boolean(output?.error)}\n      >\n        <div className=\"flex items-center gap-2\">\n          <span>Directory: </span>\n          <code className=\"font-mono text-xs\">{input?.path || \"/\"}</code>\n          <div className=\"text-muted-foreground text-xs\">\n            {output?.metadata?.count || 0} item\n            {(output?.metadata?.count || 0) !== 1 && \"s\"}\n          </div>\n        </div>\n      </StepsTrigger>\n      <StepsContent>\n        {isLoading && (\n          <StepsItem className=\"flex items-center gap-2 text-muted-foreground text-xs\">\n            <Shimmer>Listing directory...</Shimmer>\n          </StepsItem>\n        )}\n        {entries && <StepsItem>{entries}</StepsItem>}\n        {output?.error?.message && (\n          <StepsItem className=\"text-red-600 text-xs\">\n            {output.error.message}\n          </StepsItem>\n        )}\n      </StepsContent>\n    </Steps>\n  );\n}\n",
      "type": "registry:component",
      "target": "components/agent/tools/ls.tsx"
    },
    {
      "path": "src/registry/agentstart/tools/read.tsx",
      "content": "/* agent-frontmatter:start\nAGENT: Read file tool UI component\nPURPOSE: Display file reading operations with syntax-highlighted content\nUSAGE: <ReadFile part={toolPart} />\nEXPORTS: ReadFile, ReadFileProps\nFEATURES:\n  - Shows file path and reading range (offset/limit)\n  - Syntax highlighting based on file extension\n  - Displays file content with line numbers\n  - Handles partial file reads with range indicators\nSEARCHABLE: read tool, file view ui, code viewer\nagent-frontmatter:end */\n\nimport { getLanguageFromFilePath } from \"@agentstart/utils\";\nimport { SunglassesIcon } from \"@phosphor-icons/react\";\nimport type { Tools } from \"agentstart/agent\";\nimport type { InferUITools, ToolUIPart } from \"ai\";\nimport { useMemo } from \"react\";\nimport {\n  Tooltip,\n  TooltipContent,\n  TooltipTrigger,\n} from \"@/components/ui/tooltip\";\nimport { CodeBlock } from \"../code-block\";\nimport { Shimmer } from \"../shimmer\";\nimport { Steps, StepsContent, StepsItem, StepsTrigger } from \"../steps\";\n\nexport interface ReadFileProps {\n  part: ToolUIPart<InferUITools<Pick<Tools, \"read\">>>;\n}\n\nexport function ReadFile({ part: { state, input, output } }: ReadFileProps) {\n  const fileName = input?.filePath?.split(\"/\").pop() || input?.filePath;\n  const readingRange = useMemo(() => {\n    if (input?.offset === undefined && input?.limit === undefined) {\n      return null;\n    }\n    const start = input.offset ?? 0;\n    const end = input.limit ? start + input.limit : \"end\";\n    return `Lines ${start + 1} - ${end}`;\n  }, [input]);\n\n  const preview = useMemo(() => {\n    if (!output?.metadata?.content) return null;\n    const lines = output.metadata.content.split(\"\\n\");\n    const maxLines = 10;\n    const hasMore = lines.length > maxLines;\n    const language = getLanguageFromFilePath(input?.filePath);\n\n    const previewLines = lines.slice(0, maxLines);\n    const preview = hasMore\n      ? [\n          ...previewLines,\n          `// ... and ${lines.length - maxLines} more lines`,\n        ].join(\"\\n\")\n      : previewLines.join(\"\\n\");\n\n    return (\n      <CodeBlock\n        code={preview}\n        copyCode={output.metadata.content}\n        language={language}\n      />\n    );\n  }, [output?.metadata?.content, input?.filePath]);\n\n  const title = useMemo(() => {\n    return (\n      <Tooltip>\n        <TooltipTrigger\n          render={\n            <div className=\"flex items-center gap-2\">\n              <span>{fileName}</span>\n              {readingRange && (\n                <span className=\"text-muted-foreground/60\">{readingRange}</span>\n              )}\n            </div>\n          }\n        />\n        {input?.filePath && <TooltipContent>{input.filePath}</TooltipContent>}\n      </Tooltip>\n    );\n  }, [fileName, readingRange, input?.filePath]);\n  const isLoading = [\"input-streaming\", \"input-available\"].includes(state);\n\n  return (\n    <Steps data-tool-read>\n      <StepsTrigger\n        leftIcon={<SunglassesIcon weight=\"duotone\" className=\"size-4\" />}\n        loading={isLoading}\n        error={output?.status === \"error\" || Boolean(output?.error)}\n      >\n        {title}\n      </StepsTrigger>\n      <StepsContent>\n        {isLoading && (\n          <StepsItem className=\"flex items-center gap-2 text-muted-foreground text-xs\">\n            <Shimmer>Reading file...</Shimmer>\n          </StepsItem>\n        )}\n        {preview && <StepsItem>{preview}</StepsItem>}\n        {output?.error?.message && (\n          <StepsItem className=\"text-red-600 text-xs\">\n            {output.error.message}\n          </StepsItem>\n        )}\n      </StepsContent>\n    </Steps>\n  );\n}\n",
      "type": "registry:component",
      "target": "components/agent/tools/read.tsx"
    },
    {
      "path": "src/registry/agentstart/tools/todo.tsx",
      "content": "/* agent-frontmatter:start\nAGENT: Todo tool UI component\nPURPOSE: Display task list from todo tool with status indicators\nUSAGE: <Todo part={toolPart} />\nEXPORTS: Todo, TodoProps\nFEATURES:\n  - Shows todos grouped by status (inProgress, pending, completed)\n  - Color-coded status icons (blue pulse, gray circle, green check)\n  - Displays active/pending forms for each task\n  - Error state visualization for failed operations\nSEARCHABLE: todo tool, task list ui, progress tracker\nagent-frontmatter:end */\n\nimport {\n  CheckIcon,\n  CircleIcon,\n  ClockIcon,\n  KanbanIcon,\n  WarningIcon,\n} from \"@phosphor-icons/react\";\nimport type { Tools } from \"agentstart/agent\";\nimport type { InferUITools, ToolUIPart } from \"ai\";\nimport type React from \"react\";\nimport { useMemo } from \"react\";\nimport { cn } from \"@/lib/utils\";\nimport { Shimmer } from \"../shimmer\";\nimport { Steps, StepsContent, StepsItem, StepsTrigger } from \"../steps\";\n\nconst statusOrder = [\"inProgress\", \"pending\", \"completed\"];\n\nconst statusIcons: Record<string, React.ReactNode> = {\n  completed: <CheckIcon className=\"size-3.5 text-green-600\" />,\n  inProgress: <ClockIcon className=\"size-3.5 animate-pulse text-blue-600\" />,\n  pending: <CircleIcon className=\"size-3.5 text-muted-foreground\" />,\n};\n\nconst getStatusIcon = (status: string) => statusIcons[status] ?? null;\n\nconst priorityColors: Record<string, string> = {\n  high: \"text-red-600\",\n  medium: \"text-yellow-600\",\n  low: \"text-muted-foreground\",\n};\n\nconst getPriorityColor = (priority: string) =>\n  priorityColors[priority] ?? \"text-muted-foreground\";\n\nconst priorityBadges: Record<string, string> = {\n  high: \"⚡\",\n  medium: \"•\",\n  low: \"○\",\n};\n\nconst getPriorityBadge = (priority: string) => (\n  <span className={cn(\"text-xs\", getPriorityColor(priority))}>\n    {priorityBadges[priority] ?? \"\"}\n  </span>\n);\n\nexport interface TodoProps {\n  part:\n    | ToolUIPart<InferUITools<Pick<Tools, \"todoRead\">>>\n    | ToolUIPart<InferUITools<Pick<Tools, \"todoWrite\">>>;\n}\n\nexport function Todo({ part: { state, output, errorText } }: TodoProps) {\n  const isLoading = [\"input-streaming\", \"input-available\"].includes(state);\n\n  const todos = output?.metadata?.todos || [];\n\n  const groupedTodos = todos.reduce(\n    (acc, todo) => {\n      const group = acc[todo.status] || [];\n      return {\n        ...acc,\n        [todo.status]: [...group, todo],\n      };\n    },\n    {} as Record<string, typeof todos>,\n  );\n\n  const todoListContent = useMemo(() => {\n    if (output?.error) {\n      return (\n        <div className=\"flex items-center gap-2 text-red-600\">\n          <WarningIcon className=\"size-4\" weight=\"duotone\" />\n          <span className=\"text-xs\">{output.prompt}</span>\n        </div>\n      );\n    }\n\n    if (!output) {\n      return null;\n    }\n\n    if (todos.length === 0) {\n      return (\n        <div className=\"text-muted-foreground text-xs italic\">\n          No tasks in the list\n        </div>\n      );\n    }\n\n    return (\n      <div className=\"space-y-3\">\n        {statusOrder.map((status) => {\n          const statusTodos = groupedTodos[status];\n          if (!statusTodos || statusTodos.length === 0) return null;\n\n          return (\n            <div key={status}>\n              <div className=\"mb-1 font-medium text-muted-foreground text-xs capitalize\">\n                {status.replace(\"_\", \" \")}\n              </div>\n              <div className=\"space-y-1\">\n                {statusTodos.map((todo) => (\n                  <div\n                    key={todo.id}\n                    className={cn(\n                      \"flex items-start gap-2 rounded-sm p-1.5 text-xs transition-colors\",\n                      todo.status === \"completed\" && \"opacity-60\",\n                      todo.status === \"inProgress\" &&\n                        \"bg-blue-50 dark:bg-blue-900/20\",\n                      todo.priority === \"high\" &&\n                        todo.status !== \"completed\" &&\n                        \"bg-red-50 dark:bg-red-900/10\",\n                    )}\n                  >\n                    {getStatusIcon(todo.status)}\n                    <div className=\"flex-1\">\n                      <span\n                        className={cn(\n                          todo.status === \"completed\" && \"line-through\",\n                        )}\n                      >\n                        {todo.content}\n                      </span>\n                    </div>\n                    {getPriorityBadge(todo.priority)}\n                  </div>\n                ))}\n              </div>\n            </div>\n          );\n        })}\n      </div>\n    );\n  }, [output, todos.length, groupedTodos]);\n\n  return (\n    <Steps data-tool-todo>\n      <StepsTrigger\n        leftIcon={<KanbanIcon weight=\"duotone\" className=\"size-4\" />}\n        loading={isLoading}\n        error={output?.status === \"error\" || Boolean(output?.error)}\n      >\n        <span>Task List</span>\n      </StepsTrigger>\n      <StepsContent>\n        {isLoading && (\n          <StepsItem className=\"flex items-center gap-2 text-muted-foreground text-xs\">\n            <Shimmer>\n              {output ? \"Updating tasks...\" : \"Loading tasks...\"}\n            </Shimmer>\n          </StepsItem>\n        )}\n        {errorText && (\n          <StepsItem className=\"text-red-600 text-xs\">{errorText}</StepsItem>\n        )}\n        {todoListContent && <StepsItem>{todoListContent}</StepsItem>}\n      </StepsContent>\n    </Steps>\n  );\n}\n",
      "type": "registry:component",
      "target": "components/agent/tools/todo.tsx"
    },
    {
      "path": "src/registry/agentstart/tools/edit.tsx",
      "content": "/* agent-frontmatter:start\nAGENT: Edit file tool UI component\nPURPOSE: Visualize file edit operations with unified diff view\nUSAGE: <EditFile part={toolPart} />\nEXPORTS: EditFile, EditFileProps\nFEATURES:\n  - Shows unified diff with syntax highlighting\n  - Displays file path and operation type (replace/replaceAll)\n  - Uses [!code --] and [!code ++] markers for changes\n  - Supports replace_all flag visualization\nSEARCHABLE: edit tool, file edit ui, code replacement view, diff view\nagent-frontmatter:end */\n\nimport { getLanguageFromFilePath } from \"@agentstart/utils\";\nimport { SwapIcon } from \"@phosphor-icons/react\";\nimport type { Tools } from \"agentstart/agent\";\nimport type { InferUITools, ToolUIPart } from \"ai\";\nimport { useMemo } from \"react\";\nimport {\n  Tooltip,\n  TooltipContent,\n  TooltipTrigger,\n} from \"@/components/ui/tooltip\";\nimport { CodeBlock } from \"../code-block\";\nimport { Shimmer } from \"../shimmer\";\nimport { Steps, StepsContent, StepsItem, StepsTrigger } from \"../steps\";\n\nexport interface EditFileProps {\n  part: ToolUIPart<InferUITools<Pick<Tools, \"edit\">>>;\n}\n\nexport function EditFile({ part: { state, input, output } }: EditFileProps) {\n  const fileName = input?.filePath?.split(\"/\").pop() || input?.filePath;\n\n  const language = getLanguageFromFilePath(input?.filePath || \"\");\n\n  const isLoading = [\"input-streaming\", \"input-available\"].includes(state);\n\n  const changes = useMemo(() => {\n    if (!input || !input.oldString || !input.newString) return null;\n\n    // Always show as unified diff\n    const oldLines = input.oldString.split(\"\\n\");\n    const newLines = input.newString.split(\"\\n\");\n    const diffCode = [\n      ...oldLines.map((line) => `${line} // [!code --]`),\n      ...newLines.map((line) => `${line} // [!code ++]`),\n    ].join(\"\\n\");\n\n    return (\n      <CodeBlock\n        code={diffCode}\n        copyCode={input.newString}\n        language={language}\n        showDiff\n      />\n    );\n  }, [input, language]);\n\n  return (\n    <Steps data-tool-edit>\n      <StepsTrigger\n        leftIcon={<SwapIcon weight=\"duotone\" className=\"size-4\" />}\n        loading={isLoading}\n        error={output?.status === \"error\" || Boolean(output?.error)}\n      >\n        <div className=\"flex items-center gap-2\">\n          <Tooltip>\n            <TooltipTrigger\n              render={<code className=\"text-xs\">{fileName}</code>}\n            />\n            {input?.filePath && (\n              <TooltipContent>{input.filePath}</TooltipContent>\n            )}\n          </Tooltip>\n          {input?.replaceAll && (\n            <span className=\"text-muted-foreground text-xs\">(replace all)</span>\n          )}\n        </div>\n      </StepsTrigger>\n      <StepsContent>\n        {isLoading && (\n          <StepsItem className=\"flex items-center gap-2 text-muted-foreground text-xs\">\n            <Shimmer>Editing file...</Shimmer>\n          </StepsItem>\n        )}\n        <StepsItem>\n          <div className=\"flex items-center gap-2\">\n            {input?.replaceAll && (\n              <span className=\"text-muted-foreground text-xs\">\n                (replace all)\n              </span>\n            )}\n          </div>\n        </StepsItem>\n        {changes && <StepsItem>{changes}</StepsItem>}\n        {output?.error?.message && (\n          <StepsItem className=\"text-red-600 text-xs\">\n            {output.error.message}\n          </StepsItem>\n        )}\n      </StepsContent>\n    </Steps>\n  );\n}\n",
      "type": "registry:component",
      "target": "components/agent/tools/edit.tsx"
    },
    {
      "path": "src/registry/agentstart/tools/write.tsx",
      "content": "/* agent-frontmatter:start\nAGENT: Write file tool UI component\nPURPOSE: Display file writing operations with content preview\nUSAGE: <WriteFile part={toolPart} />\nEXPORTS: WriteFile, WriteFileProps\nFEATURES:\n  - Shows file path and write operation\n  - Preview first 10 lines of content with syntax highlighting\n  - Indicates when content is truncated\n  - Language detection based on file extension\nSEARCHABLE: write tool, file creation ui, save file view\nagent-frontmatter:end */\n\nimport { getLanguageFromFilePath } from \"@agentstart/utils\";\nimport { NotePencilIcon } from \"@phosphor-icons/react\";\nimport type { Tools } from \"agentstart/agent\";\nimport type { InferUITools, ToolUIPart } from \"ai\";\nimport { useMemo } from \"react\";\nimport {\n  Tooltip,\n  TooltipContent,\n  TooltipTrigger,\n} from \"@/components/ui/tooltip\";\nimport { CodeBlock } from \"../code-block\";\nimport { Shimmer } from \"../shimmer\";\nimport { Steps, StepsContent, StepsItem, StepsTrigger } from \"../steps\";\n\nexport interface WriteFileProps {\n  part: ToolUIPart<InferUITools<Pick<Tools, \"write\">>>;\n}\n\nexport function WriteFile({ part: { state, input, output } }: WriteFileProps) {\n  const fileName = input?.filePath?.split(\"/\").pop() || input?.filePath;\n  const fileContent = input?.content?.replace(/\\\\n/g, \"\\n\");\n  const isLoading = [\"input-streaming\", \"input-available\"].includes(state);\n\n  const preview = useMemo(() => {\n    if (!input || !fileContent) return null;\n    const lines = fileContent.split(\"\\n\");\n    const maxLines = 10;\n    const hasMore = lines.length > maxLines;\n    const language = getLanguageFromFilePath(input.filePath);\n\n    const previewLines = lines.slice(0, maxLines);\n\n    // Generate diff code with all lines marked as additions\n    const diffLines = previewLines.map((line) =>\n      line.trim() ? `${line} // [!code ++]` : \"\",\n    );\n    if (hasMore) {\n      diffLines.push(`// ... and ${lines.length - maxLines} more lines`);\n    }\n    const diffCode = diffLines.join(\"\\n\");\n\n    return (\n      <CodeBlock\n        code={diffCode}\n        copyCode={fileContent}\n        language={language}\n        showDiff\n      />\n    );\n  }, [input, fileContent]);\n\n  const title = useMemo(() => {\n    if (!input || !fileContent) return null;\n\n    const lineNumber = fileContent.split(\"\\n\").length ?? 0;\n    return (\n      <div className=\"flex items-center gap-2\">\n        <Tooltip>\n          <TooltipTrigger render={<span>{fileName}</span>} />\n          {input?.filePath && <TooltipContent>{input.filePath}</TooltipContent>}\n        </Tooltip>\n        <span className=\"text-green-600\">(new) +{lineNumber}</span>\n      </div>\n    );\n  }, [input, fileName, fileContent]);\n\n  return (\n    <Steps data-tool-write>\n      <StepsTrigger\n        leftIcon={<NotePencilIcon weight=\"duotone\" className=\"size-4\" />}\n        loading={isLoading}\n        error={output?.status === \"error\" || Boolean(output?.error)}\n      >\n        {title}\n      </StepsTrigger>\n      <StepsContent>\n        {isLoading && (\n          <StepsItem className=\"flex items-center gap-2 text-muted-foreground text-xs\">\n            <Shimmer>Writing file...</Shimmer>\n          </StepsItem>\n        )}\n        {preview && <StepsItem>{preview}</StepsItem>}\n        {output?.error?.message && (\n          <StepsItem className=\"text-red-600 text-xs\">\n            {output.error.message}\n          </StepsItem>\n        )}\n      </StepsContent>\n    </Steps>\n  );\n}\n",
      "type": "registry:component",
      "target": "components/agent/tools/write.tsx"
    },
    {
      "path": "src/registry/agentstart/response.tsx",
      "content": "/* agent-frontmatter:start\nAGENT: Markdown response renderer\nPURPOSE: Render assistant text parts using Streamdown with stable memoization\nUSAGE: import { Response } from \\\"@/components/agent/response\\\"\nEXPORTS: Response\nFEATURES:\n  - Applies consistent typography to markdown streams\n  - Memoizes children to avoid unnecessary rerenders\nSEARCHABLE: markdown renderer, streamdown response, agent output\nagent-frontmatter:end */\n\n\"use client\";\n\nimport {\n  MagnifyingGlassMinusIcon,\n  MagnifyingGlassPlusIcon,\n} from \"@phosphor-icons/react\";\nimport { type ComponentProps, memo } from \"react\";\nimport Zoom from \"react-medium-image-zoom\";\nimport type { BundledLanguage } from \"shiki/bundle/web\";\nimport { Streamdown } from \"streamdown\";\nimport { cn } from \"@/lib/utils\";\nimport { CodeBlock } from \"./code-block\";\nimport \"react-medium-image-zoom/dist/styles.css\";\n\ntype ResponseProps = ComponentProps<typeof Streamdown>;\n\nexport const Response = memo(\n  ({ className, ...props }: ResponseProps) => (\n    <Streamdown\n      className={cn(\n        \"size-full text-base [&>*:first-child]:mt-0 [&>*:last-child]:mb-0\",\n        className,\n      )}\n      components={{\n        pre: ({ children, node, ...props }) => {\n          const [firstChild] = node?.children ?? [];\n\n          if (\n            firstChild &&\n            firstChild.type === \"element\" &&\n            firstChild.tagName === \"code\" &&\n            firstChild.children[0]?.type === \"text\"\n          ) {\n            const { className } = firstChild.properties;\n            const [, language = \"plaintext\"] =\n              /language-(.+)/.exec(String(className) || \"\") ?? [];\n            const code = firstChild.children[0].value.trim();\n\n            return (\n              <pre {...props}>\n                <CodeBlock\n                  className=\"my-4\"\n                  code={code}\n                  language={language as BundledLanguage}\n                />\n              </pre>\n            );\n          }\n\n          const lang = props.className?.split(\"language-\")[1] ?? \"markdown\";\n          return (\n            <pre {...props}>\n              <CodeBlock\n                className=\"my-4\"\n                code={children as string}\n                language={lang as BundledLanguage}\n              />\n            </pre>\n          );\n        },\n        img: (props) => {\n          const { src, alt, ...rest } = props;\n          if (!src) return null;\n          return (\n            <Zoom\n              IconZoom={() => (\n                <MagnifyingGlassPlusIcon\n                  weight=\"duotone\"\n                  className=\"size-5.5\"\n                />\n              )}\n              IconUnzoom={() => (\n                <MagnifyingGlassMinusIcon\n                  weight=\"duotone\"\n                  className=\"size-5.5\"\n                />\n              )}\n            >\n              <img\n                className=\"my-2 block max-h-40 rounded-lg\"\n                src={src}\n                loading=\"lazy\"\n                alt={alt}\n                {...rest}\n              />\n            </Zoom>\n          );\n        },\n      }}\n      {...props}\n    />\n  ),\n  (prevProps, nextProps) => prevProps.children === nextProps.children,\n);\n\nResponse.displayName = \"Response\";\n",
      "type": "registry:component",
      "target": "components/agent/response.tsx"
    },
    {
      "path": "src/registry/agentstart/code-block.tsx",
      "content": "/* agent-frontmatter:start\nAGENT: Code block component with syntax highlighting\nPURPOSE: Render syntax-highlighted code snippets with line numbers and copy functionality\nUSAGE: <CodeBlock code={code} language=\"typescript\" showLineNumbers copyCode={originalCode} />\nEXPORTS: CodeBlock, CodeBlockCopyButton, highlightCode\nFEATURES:\n  - Dual-theme syntax highlighting (light/dark) using Shiki\n  - Optional line number display\n  - Copy-to-clipboard button with success feedback\n  - Separate copyCode prop to copy original content without diff markers\n  - Supports all Shiki bundled languages and diff notation\nSEARCHABLE: code block, syntax highlighting, shiki, copy button, diff\nagent-frontmatter:end */\n\n\"use client\";\n\nimport { CheckIcon, CopyIcon } from \"@phosphor-icons/react\";\nimport { transformerNotationDiff } from \"@shikijs/transformers\";\nimport { useTheme } from \"agentstart/client\";\nimport {\n  type ComponentProps,\n  createContext,\n  type HTMLAttributes,\n  useContext,\n  useEffect,\n  useRef,\n  useState,\n} from \"react\";\nimport {\n  type BundledLanguage,\n  codeToHtml,\n  type ShikiTransformer,\n} from \"shiki/bundle/web\";\nimport { Button } from \"@/components/ui/button\";\nimport { ScrollArea } from \"@/components/ui/scroll-area\";\nimport { cn } from \"@/lib/utils\";\n\ntype CodeBlockProps = HTMLAttributes<HTMLDivElement> & {\n  code: string;\n  language: BundledLanguage;\n  showLineNumbers?: boolean;\n  showCopyButton?: boolean;\n  showDiff?: boolean;\n  /** Original code without diff markers for copying */\n  copyCode?: string;\n};\n\ntype CodeBlockContextType = {\n  code: string;\n  copyCode: string;\n};\n\nconst CodeBlockContext = createContext<CodeBlockContextType>({\n  code: \"\",\n  copyCode: \"\",\n});\n\nconst lineNumberTransformer: ShikiTransformer = {\n  name: \"line-numbers\",\n  line(node, line) {\n    node.children.unshift({\n      type: \"element\",\n      tagName: \"span\",\n      properties: {\n        className: [\n          \"inline-block\",\n          \"min-w-10\",\n          \"mr-4\",\n          \"text-right\",\n          \"select-none\",\n          \"text-muted-foreground\",\n        ],\n      },\n      children: [{ type: \"text\", value: String(line) }],\n    });\n  },\n};\n\nexport async function highlightCode({\n  code,\n  language,\n  showLineNumbers = false,\n  showDiff = false,\n}: {\n  code: string;\n  language: BundledLanguage;\n  showLineNumbers: boolean;\n  showDiff: boolean;\n}) {\n  const transformers: ShikiTransformer[] = [];\n\n  if (showLineNumbers) {\n    transformers.push(lineNumberTransformer);\n  }\n\n  if (showDiff) {\n    transformers.push(transformerNotationDiff());\n  }\n\n  return await Promise.all([\n    codeToHtml(code, {\n      lang: language,\n      theme: \"vitesse-light\",\n      transformers,\n    }),\n    codeToHtml(code, {\n      lang: language,\n      theme: \"vesper\",\n      transformers,\n    }),\n  ]);\n}\n\nexport const CodeBlock = ({\n  code,\n  language,\n  showLineNumbers = false,\n  showCopyButton = true,\n  showDiff = false,\n  copyCode,\n  className,\n  children,\n  ...props\n}: CodeBlockProps) => {\n  const [html, setHtml] = useState<string>(\"\");\n  const [darkHtml, setDarkHtml] = useState<string>(\"\");\n  const mounted = useRef(false);\n  const { resolvedTheme } = useTheme();\n\n  useEffect(() => {\n    highlightCode({ code, language, showLineNumbers, showDiff }).then(\n      ([light, dark]) => {\n        if (!mounted.current) {\n          setHtml(light);\n          setDarkHtml(dark);\n          mounted.current = true;\n        }\n      },\n    );\n\n    return () => {\n      mounted.current = false;\n    };\n  }, [code, language, showLineNumbers, showDiff]);\n\n  return (\n    <CodeBlockContext.Provider value={{ code, copyCode: copyCode ?? code }}>\n      <div\n        className={cn(\n          \"group/code-block relative max-h-[200px] overflow-hidden rounded-lg border text-foreground\",\n          \"[&_.diff.add]:bg-green-500/10 [&_.diff.add]:text-green-600 [&_.diff.add]:before:absolute [&_.diff.add]:before:left-1 [&_.diff.add]:before:content-['+']\",\n          \"[&_.diff.remove]:bg-red-500/10 [&_.diff.remove]:text-red-600 [&_.diff.remove]:opacity-70 [&_.diff.remove]:before:absolute [&_.diff.remove]:before:left-1 [&_.diff.remove]:before:content-['-']\",\n          \"dark:[&_.diff.add]:bg-green-500/20 dark:[&_.diff.add]:text-green-400\",\n          \"dark:[&_.diff.remove]:bg-red-500/20 dark:[&_.diff.remove]:text-red-400\",\n          className,\n        )}\n        {...props}\n      >\n        <ScrollArea className=\"max-h-[200px]\">\n          <div\n            className={cn(\n              \"[&>pre]:m-0 [&>pre]:bg-background! [&>pre]:text-foreground! [&>pre]:text-sm\",\n              \"[&_code]:wrap-break-word [&_code]:block [&_code]:w-full [&_code]:border-none [&_code]:font-mono [&_code]:text-sm [&_code]:leading-normal\",\n              \"[&_.line]:relative [&_.line]:inline-block [&_.line]:w-full [&_.line]:px-4\",\n            )}\n            dangerouslySetInnerHTML={{\n              __html: resolvedTheme === \"dark\" ? darkHtml : html,\n            }}\n          />\n          {children && (\n            <div className=\"absolute top-2 right-2 flex items-center gap-2\">\n              {children}\n            </div>\n          )}\n        </ScrollArea>\n        {showCopyButton && (\n          <CodeBlockCopyButton className=\"absolute top-2 right-2 opacity-0 transition-opacity group-hover/code-block:opacity-100\" />\n        )}\n      </div>\n    </CodeBlockContext.Provider>\n  );\n};\n\nexport type CodeBlockCopyButtonProps = ComponentProps<typeof Button> & {\n  onCopy?: () => void;\n  onError?: (error: Error) => void;\n  timeout?: number;\n};\n\nexport const CodeBlockCopyButton = ({\n  onCopy,\n  onError,\n  timeout = 2000,\n  children,\n  className,\n  ...props\n}: CodeBlockCopyButtonProps) => {\n  const [isCopied, setIsCopied] = useState(false);\n  const { copyCode } = useContext(CodeBlockContext);\n\n  const copyToClipboard = async () => {\n    if (typeof window === \"undefined\" || !navigator?.clipboard?.writeText) {\n      onError?.(new Error(\"Clipboard API not available\"));\n      return;\n    }\n\n    try {\n      await navigator.clipboard.writeText(copyCode);\n      setIsCopied(true);\n      onCopy?.();\n      setTimeout(() => setIsCopied(false), timeout);\n    } catch (error) {\n      onError?.(error as Error);\n    }\n  };\n\n  const Icon = isCopied ? (\n    <CheckIcon weight=\"bold\" />\n  ) : (\n    <CopyIcon weight=\"duotone\" />\n  );\n\n  return (\n    <Button\n      className={cn(\"shrink-0\", className)}\n      onClick={copyToClipboard}\n      size=\"icon\"\n      variant=\"ghost\"\n      {...props}\n    >\n      {children ?? Icon}\n    </Button>\n  );\n};\n",
      "type": "registry:component",
      "target": "components/agent/code-block.tsx"
    },
    {
      "path": "src/registry/agentstart/tools/reasoning.tsx",
      "content": "/* agent-frontmatter:start\nAGENT: Reasoning disclosure widget\nPURPOSE: Show expandable reasoning traces with streaming-aware behavior\nUSAGE: import { Reasoning, ReasoningTrigger, ReasoningContent } from \\\"@/components/agent/reasoning\\\"\nEXPORTS: Reasoning, ReasoningTrigger, ReasoningContent\nFEATURES:\n  - Auto-opens while streaming and auto-closes after completion\n  - Displays duration summaries and shimmer placeholder\nSEARCHABLE: reasoning panel, collapsible thinking, agent reasoning ui\nagent-frontmatter:end */\n\n\"use client\";\n\nimport { BrainIcon, CaretDownIcon } from \"@phosphor-icons/react\";\nimport type { ComponentProps } from \"react\";\nimport { createContext, memo, useContext, useEffect, useState } from \"react\";\n\n// Simple implementation of useControllableState for Base UI compatibility\nfunction useControllableState<T>({\n  prop,\n  defaultProp,\n  onChange,\n}: {\n  prop?: T;\n  defaultProp: T;\n  onChange?: (value: T) => void;\n}) {\n  const [state, setState] = useState(prop ?? defaultProp);\n\n  useEffect(() => {\n    if (prop !== undefined) {\n      setState(prop);\n    }\n  }, [prop]);\n\n  const setValue = (value: T) => {\n    if (prop === undefined) {\n      setState(value);\n    }\n    onChange?.(value);\n  };\n\n  return [state, setValue] as const;\n}\n\nimport { cn } from \"@/lib/utils\";\nimport { Response } from \"../response\";\nimport { Shimmer } from \"../shimmer\";\nimport { Steps, StepsContent, StepsItem, StepsTrigger } from \"../steps\";\n\ntype ReasoningContextValue = {\n  isStreaming: boolean;\n  isOpen: boolean;\n  setIsOpen: (open: boolean) => void;\n  duration: number;\n};\n\nconst ReasoningContext = createContext<ReasoningContextValue | null>(null);\n\nconst useReasoning = () => {\n  const context = useContext(ReasoningContext);\n  if (!context) {\n    throw new Error(\"Reasoning components must be used within Reasoning\");\n  }\n  return context;\n};\n\nexport type ReasoningProps = ComponentProps<typeof Steps> & {\n  isStreaming?: boolean;\n  open?: boolean;\n  defaultOpen?: boolean;\n  onOpenChange?: (open: boolean) => void;\n  duration?: number;\n};\n\nconst AUTO_CLOSE_DELAY = 1000;\nconst MS_IN_S = 1000;\n\nexport const Reasoning = memo(\n  ({\n    className,\n    isStreaming = false,\n    open,\n    defaultOpen = true,\n    onOpenChange,\n    duration: durationProp,\n    children,\n    ...props\n  }: ReasoningProps) => {\n    const [isOpen, setIsOpen] = useControllableState({\n      prop: open,\n      defaultProp: defaultOpen,\n      onChange: onOpenChange,\n    });\n    const [duration, setDuration] = useControllableState({\n      prop: durationProp,\n      defaultProp: 0,\n    });\n\n    const [hasAutoClosed, setHasAutoClosed] = useState(false);\n    const [startTime, setStartTime] = useState<number | null>(null);\n\n    // Track duration when streaming starts and ends\n    useEffect(() => {\n      if (isStreaming) {\n        if (startTime === null) {\n          setStartTime(Date.now());\n        }\n      } else if (startTime !== null) {\n        setDuration(Math.ceil((Date.now() - startTime) / MS_IN_S));\n        setStartTime(null);\n      }\n    }, [isStreaming, startTime, setDuration]);\n\n    // Auto-open when streaming starts, auto-close when streaming ends (once only)\n    useEffect(() => {\n      if (defaultOpen && !isStreaming && isOpen && !hasAutoClosed) {\n        // Add a small delay before closing to allow user to see the content\n        const timer = setTimeout(() => {\n          setIsOpen(false);\n          setHasAutoClosed(true);\n        }, AUTO_CLOSE_DELAY);\n\n        return () => clearTimeout(timer);\n      }\n    }, [isStreaming, isOpen, defaultOpen, setIsOpen, hasAutoClosed]);\n\n    const handleOpenChange = (newOpen: boolean) => {\n      setIsOpen(newOpen);\n    };\n\n    return (\n      <ReasoningContext.Provider\n        value={{ isStreaming, isOpen, setIsOpen, duration }}\n      >\n        <Steps\n          data-tool-reasoning\n          className={cn(\"not-prose\", className)}\n          onOpenChange={handleOpenChange}\n          open={isOpen}\n          {...props}\n        >\n          {children}\n        </Steps>\n      </ReasoningContext.Provider>\n    );\n  },\n);\n\nexport type ReasoningTriggerProps = ComponentProps<typeof StepsTrigger>;\n\nexport const getThinkingMessage = (isStreaming: boolean, duration?: number) => {\n  if (isStreaming || duration === 0) {\n    return <Shimmer duration={1}>Thinking...</Shimmer>;\n  }\n  if (duration === undefined) {\n    return <p>Thought for a few seconds</p>;\n  }\n  return <p>Thought for {duration} seconds</p>;\n};\n\nexport const ReasoningTrigger = memo(\n  ({ className, children, ...props }: ReasoningTriggerProps) => {\n    const { isStreaming, isOpen, duration } = useReasoning();\n\n    return (\n      <StepsTrigger\n        leftIcon={<BrainIcon className=\"size-4\" weight=\"duotone\" />}\n        loading={isStreaming}\n        className={cn(\n          \"flex w-full items-center gap-2 text-muted-foreground text-sm transition-colors hover:text-foreground\",\n          className,\n        )}\n        {...props}\n      >\n        {children ?? (\n          <>\n            {getThinkingMessage(isStreaming, duration)}\n            <CaretDownIcon\n              className={cn(\n                \"size-4 transition-transform\",\n                isOpen ? \"rotate-180\" : \"rotate-0\",\n              )}\n            />\n          </>\n        )}\n      </StepsTrigger>\n    );\n  },\n);\n\nexport type ReasoningContentProps = ComponentProps<typeof StepsContent> & {\n  children: string;\n};\n\nexport const ReasoningContent = memo(\n  ({ className, children, ...props }: ReasoningContentProps) => (\n    <StepsContent\n      className={cn(\n        \"data-[state=closed]:fade-out-0 data-[state=closed]:slide-out-to-top-2 data-[state=open]:slide-in-from-top-2 text-muted-foreground text-sm outline-none data-[state=closed]:animate-out data-[state=open]:animate-in\",\n        className,\n      )}\n      {...props}\n    >\n      <StepsItem>\n        <Response className=\"grid gap-2\">{children}</Response>\n      </StepsItem>\n    </StepsContent>\n  ),\n);\n\nReasoning.displayName = \"Reasoning\";\nReasoningTrigger.displayName = \"ReasoningTrigger\";\nReasoningContent.displayName = \"ReasoningContent\";\n",
      "type": "registry:component",
      "target": "components/agent/tools/reasoning.tsx"
    }
  ]
}