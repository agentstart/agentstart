{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "conversation",
  "type": "registry:component",
  "title": "AgentStart Conversation",
  "description": "Render thread messages with auto-scroll, welcome state, and tool-aware formatting. Loads thread transcripts with TanStack Query and displays AI responses and tool interactions.",
  "dependencies": [
    "@base-ui-components/react",
    "@phosphor-icons/react",
    "@tanstack/react-query",
    "agentstart",
    "ai",
    "react",
    "use-stick-to-bottom"
  ],
  "registryDependencies": [
    "spinner",
    "@coss/button",
    "@coss/empty",
    "@coss/avatar",
    "@coss/provider",
    "message",
    "response",
    "sources",
    "message-part-view",
    "shimmer",
    "suggested-prompts",
    "welcome-message",
    "relative-time"
  ],
  "files": [
    {
      "path": "src/registry/agentstart/conversation/index.tsx",
      "content": "/* agent-frontmatter:start\nAGENT: Agent conversation viewer\nPURPOSE: Render thread messages with auto-scroll and tool-aware formatting\nUSAGE: <Conversation threadId={threadId} />\nEXPORTS: Conversation, ConversationProps, ConversationContent, ConversationEmptyState, ConversationScrollButton\nFEATURES:\n  - Loads thread transcripts with TanStack Query and the AgentStart client\n  - Displays AI responses and tool interactions with timeline styling\n  - Keeps the conversation pinned to the latest message with scroll controls\nSEARCHABLE: conversation viewer, thread messages, agentstart conversation, auto scroll\nagent-frontmatter:end */\n\n\"use client\";\n\nimport { ScrollArea as ScrollAreaPrimitive } from \"@base-ui-components/react/scroll-area\";\nimport {\n  ArrowsClockwiseIcon,\n  CaretDownIcon,\n  ChatSlashIcon,\n} from \"@phosphor-icons/react\";\nimport { useQuery } from \"@tanstack/react-query\";\nimport type { AgentStartUIMessage } from \"agentstart/agent\";\nimport {\n  type AgentStore,\n  useAgentStartContext,\n  useAgentStore,\n  useThinkingExtractor,\n} from \"agentstart/client\";\nimport type { ComponentProps, ReactNode } from \"react\";\nimport { useCallback, useEffect, useRef, useState } from \"react\";\nimport { useStickToBottom } from \"use-stick-to-bottom\";\nimport { Button } from \"@/components/ui/button\";\nimport {\n  Empty,\n  EmptyContent,\n  EmptyDescription,\n  EmptyHeader,\n  EmptyTitle,\n} from \"@/components/ui/empty\";\nimport { Skeleton } from \"@/components/ui/skeleton\";\nimport { cn } from \"@/lib/utils\";\nimport type { PromptInputLayout } from \"../prompt-input\";\nimport { StatusIndicators } from \"../shimmer\";\nimport { SuggestedPrompts } from \"../suggested-prompts\";\nimport { WelcomeMessage } from \"../welcome-message\";\nimport { ConversationMessage } from \"./conversation-message\";\n\n// Helper functions\nconst getFileCount = (files: unknown): number => {\n  if (files instanceof FileList) return files.length;\n  if (Array.isArray(files)) return files.length;\n  return 0;\n};\n\nconst hasNewThreadDraftContent = (draft: unknown): boolean => {\n  if (!draft || typeof draft !== \"object\") return false;\n  const d = draft as { text?: string; files?: unknown };\n  const hasText = (d.text?.trim() ?? \"\").length > 0;\n  const fileCount = getFileCount(d.files);\n  return hasText || fileCount > 0;\n};\n\nconst tailwindSpacingToPx = (value: number): number => value * 4;\n\n// Internal hook: Safe store access with fallback when useThread is not used\ntype SetMessagesFn = (\n  messages:\n    | AgentStartUIMessage[]\n    | ((prev: AgentStartUIMessage[]) => AgentStartUIMessage[]),\n) => void;\n\ninterface UseSafeStoreReturn {\n  messages: AgentStartUIMessage[];\n  safeSetMessages: SetMessagesFn;\n  isUsingThread: boolean;\n}\n\n/**\n * Hook that provides safe access to agent store with fallback when useThread is not used.\n * This hook detects whether useThread has been initialized by checking if store.id is set.\n * If useThread is active, it uses the official setMessages. Otherwise, it falls back to\n * using _syncState to update the store directly.\n */\nfunction useSafeStore(storeId: string = \"default\"): UseSafeStoreReturn {\n  // Get current messages\n  const messages = useAgentStore<AgentStartUIMessage, AgentStartUIMessage[]>(\n    (state) => state.messages,\n    storeId,\n  );\n\n  // Get setMessages (will be no-op if useThread is not used)\n  const setMessages = useAgentStore<\n    AgentStartUIMessage,\n    AgentStore<AgentStartUIMessage>[\"setMessages\"]\n  >((state) => state.setMessages, storeId);\n\n  // Get store.id to detect if useThread is active\n  const threadStoreId = useAgentStore<AgentStartUIMessage, string>(\n    (state) => state.id,\n    storeId,\n  );\n\n  // Get _syncState as fallback mechanism\n  const _syncState = useAgentStore<\n    AgentStartUIMessage,\n    ((newState: Partial<AgentStore<AgentStartUIMessage>>) => void) | undefined\n  >((state) => (state as any)._syncState, storeId);\n\n  // Check if useThread has been used (store.id will be set by useThread)\n  const isUsingThread = Boolean(threadStoreId);\n\n  // Create safe setMessages that works with or without useThread\n  const safeSetMessages = useCallback<SetMessagesFn>(\n    (newMessages) => {\n      if (isUsingThread) {\n        // useThread is active, use the official setMessages\n        setMessages(newMessages);\n      } else if (_syncState) {\n        // No useThread, use _syncState to update the store directly\n        const resolvedMessages =\n          typeof newMessages === \"function\"\n            ? newMessages(messages)\n            : newMessages;\n        _syncState({ messages: resolvedMessages });\n      }\n    },\n    [isUsingThread, setMessages, _syncState, messages],\n  );\n\n  return {\n    messages,\n    safeSetMessages,\n    isUsingThread,\n  };\n}\n\nexport type ConversationProps = Omit<\n  ComponentProps<typeof ScrollAreaPrimitive.Root>,\n  \"children\"\n> & {\n  contentClassName?: string;\n  layout?: PromptInputLayout;\n  /**\n   * Optional messages used to hydrate the UI before the client store syncs.\n   */\n  initialMessages?: AgentStartUIMessage[];\n  /**\n   * Custom empty state element when no messages are present.\n   */\n  emptyState?: ReactNode;\n  /**\n   * Custom loading state element while fetching the thread history.\n   */\n  loadingState?: ReactNode;\n  /**\n   * Provide a custom error renderer when fetching messages fails.\n   */\n  errorState?: (error: Error, retry: () => void) => ReactNode;\n};\n\ntype ConversationEmptyStateProps = ComponentProps<\"div\"> & {\n  title?: string;\n  description?: string;\n  icon?: ReactNode;\n};\n\nconst ConversationEmptyState = ({\n  className,\n  title = \"No messages yet\",\n  description = \"Start a conversation to see messages here\",\n  icon,\n  children,\n  ...props\n}: ConversationEmptyStateProps) => (\n  <div\n    className={cn(\n      \"flex size-full flex-col items-center justify-center gap-3\",\n      className,\n    )}\n    {...props}\n  >\n    {children ?? (\n      <>\n        {icon && <div className=\"text-muted-foreground\">{icon}</div>}\n        <div className=\"space-y-1\">\n          <h3 className=\"font-medium text-sm\">{title}</h3>\n          {description && (\n            <p className=\"text-muted-foreground text-sm\">{description}</p>\n          )}\n        </div>\n      </>\n    )}\n  </div>\n);\n\ntype ConversationScrollButtonProps = ComponentProps<typeof Button> & {\n  isAtBottom: boolean;\n  scrollToBottom: () => void;\n};\n\nconst ConversationScrollButton = ({\n  className,\n  isAtBottom,\n  scrollToBottom,\n  ...props\n}: ConversationScrollButtonProps) => {\n  if (isAtBottom) {\n    return null;\n  }\n\n  return (\n    <Button\n      className={cn(\n        \"absolute bottom-4 left-[50%] translate-x-[-50%] rounded-full\",\n        className,\n      )}\n      onClick={() => scrollToBottom()}\n      size=\"icon\"\n      type=\"button\"\n      variant=\"outline\"\n      {...props}\n    >\n      <CaretDownIcon className=\"size-4\" />\n    </Button>\n  );\n};\n\ntype UIAgentStore = AgentStore<AgentStartUIMessage>;\n\nexport function Conversation({\n  className,\n  contentClassName,\n  emptyState,\n  loadingState,\n  errorState,\n  initialMessages,\n  layout = \"default\",\n  ...props\n}: ConversationProps) {\n  const { orpc, threadId } = useAgentStartContext();\n  const isMobileLayout = layout === \"mobile\";\n  const rootRef = useRef<HTMLDivElement | null>(null);\n  const [promptFooterHeight, setPromptFooterHeight] = useState<number | null>(\n    null,\n  );\n\n  const { scrollRef, contentRef, isAtBottom, scrollToBottom } =\n    useStickToBottom({\n      initial: \"instant\",\n      resize: \"instant\",\n    });\n\n  useEffect(() => {\n    const root = rootRef.current;\n    if (!root) return;\n\n    const footer = root.nextElementSibling;\n    if (!(footer instanceof HTMLElement)) {\n      setPromptFooterHeight(null);\n      return;\n    }\n\n    const updateHeight = () => {\n      const measured = Math.ceil(footer.getBoundingClientRect().height);\n      setPromptFooterHeight((previous) =>\n        previous === measured ? previous : measured,\n      );\n    };\n\n    updateHeight();\n\n    if (typeof ResizeObserver === \"undefined\") {\n      const resizeListener = () => updateHeight();\n      window.addEventListener(\"resize\", resizeListener);\n      return () => {\n        window.removeEventListener(\"resize\", resizeListener);\n      };\n    }\n\n    const observer = new ResizeObserver(() => {\n      updateHeight();\n    });\n    observer.observe(footer);\n\n    return () => {\n      observer.disconnect();\n    };\n  }, []);\n\n  const resolvedStoreId = threadId ?? \"default\";\n\n  // Use safe store hook that handles both with and without useThread\n  const { messages, safeSetMessages } = useSafeStore(resolvedStoreId);\n\n  // Extract thinking status from reasoning parts\n  useThinkingExtractor(resolvedStoreId);\n\n  const status = useAgentStore<AgentStartUIMessage, UIAgentStore[\"status\"]>(\n    (state) => state.status,\n    resolvedStoreId,\n  );\n  const storeError = useAgentStore<AgentStartUIMessage, UIAgentStore[\"error\"]>(\n    (state) => state.error,\n    resolvedStoreId,\n  );\n  const regenerate = useAgentStore<\n    AgentStartUIMessage,\n    UIAgentStore[\"regenerate\"]\n  >((state) => state.regenerate, resolvedStoreId);\n  const newThreadDraft = useAgentStore<\n    AgentStartUIMessage,\n    UIAgentStore[\"newThreadDraft\"]\n  >((state) => state.newThreadDraft);\n  const messageQueue = useAgentStore<\n    AgentStartUIMessage,\n    UIAgentStore[\"messageQueue\"]\n  >((state) => state.messageQueue);\n  const thinkingStatus = useAgentStore<\n    AgentStartUIMessage,\n    UIAgentStore[\"thinkingStatus\"]\n  >((state) => state.thinkingStatus, resolvedStoreId);\n  const hasQueue = messageQueue.length > 0;\n  const hasNewThreadDraft = hasNewThreadDraftContent(newThreadDraft);\n  const fallbackContentPaddingPx = isMobileLayout\n    ? tailwindSpacingToPx(22)\n    : tailwindSpacingToPx(48);\n  const fallbackButtonOffsetPx = isMobileLayout\n    ? tailwindSpacingToPx(hasQueue ? 27 : 22)\n    : tailwindSpacingToPx(hasQueue ? 52 : 42);\n  const measuredFooterHeight = promptFooterHeight ?? 0;\n  const contentPaddingPx = Math.max(\n    measuredFooterHeight + (isMobileLayout ? 16 : 24),\n    fallbackContentPaddingPx,\n  );\n  const scrollButtonOffsetPx = Math.max(\n    measuredFooterHeight + (isMobileLayout ? 12 : 16),\n    fallbackButtonOffsetPx,\n  );\n\n  const queryResult = useQuery(\n    orpc.message.get.queryOptions({\n      input: { threadId: threadId! },\n      enabled: Boolean(threadId) && !hasNewThreadDraft,\n      initialData: threadId ? initialMessages : undefined,\n    }),\n  );\n\n  const {\n    data: fetchedMessages,\n    error: queryError,\n    isError,\n    isLoading,\n    isFetching,\n    refetch,\n  } = queryResult;\n\n  useEffect(() => {\n    // If no threadId is provided, clear messages\n    if (!threadId) {\n      if (messages.length > 0) {\n        safeSetMessages([]);\n      }\n      return;\n    }\n\n    // If no messages were fetched, do nothing\n    if (!fetchedMessages?.length) {\n      return;\n    }\n\n    // If there are already messages in the store, do nothing\n    if (messages.length > 0) {\n      return;\n    }\n\n    // Set the fetched messages into the store\n    safeSetMessages(fetchedMessages);\n  }, [fetchedMessages, messages, safeSetMessages, threadId]);\n\n  const fetchError = isError ? (queryError as Error) : null;\n  const hasMessages = messages.length > 0;\n  const showInitialLoading =\n    Boolean(threadId) &&\n    !hasMessages &&\n    (hasNewThreadDraft || isLoading || (isFetching && !fetchedMessages));\n\n  const defaultEmptyState = (\n    <ConversationEmptyState\n      icon={\n        <ChatSlashIcon\n          className=\"size-12 text-muted-foreground\"\n          weight=\"duotone\"\n        />\n      }\n      title=\"Start a conversation\"\n      description=\"Send a message to begin chatting with the agent.\"\n    >\n      <WelcomeMessage className=\"mt-4\" />\n    </ConversationEmptyState>\n  );\n\n  const defaultLoadingState = (\n    <div className=\"mx-auto flex w-full flex-col gap-4 px-4 py-2 sm:min-w-[390px] sm:max-w-3xl\">\n      <div className=\"flex justify-start\">\n        <div className=\"max-w-[80%]\">\n          <Skeleton className=\"mb-2 h-4 w-24\" />\n          <Skeleton className=\"mb-1 h-3 w-48\" />\n          <Skeleton className=\"h-3 w-32\" />\n        </div>\n      </div>\n      <div className=\"flex justify-end\">\n        <div className=\"max-w-[80%]\">\n          <Skeleton className=\"mb-2 h-4 w-20\" />\n          <Skeleton className=\"h-3 w-40\" />\n        </div>\n      </div>\n      <div className=\"flex justify-start\">\n        <div className=\"max-w-[80%]\">\n          <Skeleton className=\"mb-2 h-4 w-28\" />\n          <Skeleton className=\"mb-1 h-3 w-56\" />\n          <Skeleton className=\"h-3 w-44\" />\n        </div>\n      </div>\n      <div className=\"flex justify-start\">\n        <div className=\"max-w-[80%]\">\n          <Skeleton className=\"mb-2 h-4 w-24\" />\n          <Skeleton className=\"h-3 w-36\" />\n        </div>\n      </div>\n    </div>\n  );\n\n  const defaultErrorState = fetchError && (\n    <ConversationEmptyState\n      icon={\n        <ChatSlashIcon className=\"size-12 text-destructive\" weight=\"duotone\" />\n      }\n      title=\"Unable to load messages\"\n      description={fetchError.message ?? \"Please try again.\"}\n    >\n      <Button onClick={() => refetch()} type=\"button\" variant=\"outline\">\n        Retry\n      </Button>\n    </ConversationEmptyState>\n  );\n\n  const resolvedEmptyState = emptyState ?? defaultEmptyState;\n  const resolvedLoadingState = loadingState ?? defaultLoadingState;\n  const resolvedErrorState = fetchError\n    ? (errorState?.(fetchError, () => refetch()) ?? defaultErrorState)\n    : null;\n  const shouldShowStatusIndicators =\n    status === \"streaming\" || status === \"submitted\";\n\n  return (\n    <ScrollAreaPrimitive.Root\n      className={cn(\"relative flex size-full flex-col\", className)}\n      ref={rootRef}\n      {...props}\n    >\n      <ScrollAreaPrimitive.Viewport\n        className={cn(\n          \"size-full overscroll-contain rounded-[inherit] outline-none transition-shadow focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-1 focus-visible:ring-offset-background\",\n          contentClassName,\n        )}\n        ref={scrollRef}\n      >\n        <ScrollAreaPrimitive.Content\n          ref={contentRef}\n          className={cn(\n            \"mx-auto flex flex-col gap-4 px-4 py-2 sm:min-w-[390px]! sm:max-w-3xl\",\n            contentClassName,\n          )}\n          style={{ paddingBottom: `${contentPaddingPx}px` }}\n        >\n          {resolvedErrorState ? (\n            resolvedErrorState\n          ) : hasMessages ? (\n            <div className=\"flex flex-col gap-2\">\n              {messages.map((message, index) => {\n                const isLastMessage = index === messages.length - 1;\n                return (\n                  <ConversationMessage\n                    key={message.id}\n                    message={message}\n                    isLastMessage={isLastMessage}\n                    status={status}\n                    regenerate={regenerate}\n                  />\n                );\n              })}\n              {shouldShowStatusIndicators && (\n                <StatusIndicators\n                  text={thinkingStatus ?? undefined}\n                  randomText={!thinkingStatus}\n                />\n              )}\n              {storeError && (\n                <Empty>\n                  <EmptyHeader>\n                    <EmptyTitle className=\"text-destructive\">\n                      Error Occurred\n                    </EmptyTitle>\n                    <EmptyDescription className=\"overflow-hidden sm:min-w-[390px] sm:max-w-3xl\">\n                      {storeError.message ?? \"Unexpected error\"}\n                    </EmptyDescription>\n                  </EmptyHeader>\n                  <EmptyContent>\n                    <Button\n                      variant=\"outline\"\n                      size=\"sm\"\n                      onClick={() =>\n                        regenerate({\n                          body: {\n                            threadId,\n                          },\n                        })\n                      }\n                    >\n                      <ArrowsClockwiseIcon\n                        className=\"size-4\"\n                        weight=\"duotone\"\n                      />\n                      Retry\n                    </Button>\n                  </EmptyContent>\n                </Empty>\n              )}\n            </div>\n          ) : showInitialLoading ? (\n            resolvedLoadingState\n          ) : (\n            resolvedEmptyState\n          )}\n\n          {!shouldShowStatusIndicators && (\n            <SuggestedPrompts\n              className={cn({\n                \"pt-0\": !hasMessages,\n              })}\n            />\n          )}\n        </ScrollAreaPrimitive.Content>\n      </ScrollAreaPrimitive.Viewport>\n      <ScrollAreaPrimitive.Scrollbar\n        data-slot=\"scroll-area-scrollbar\"\n        orientation=\"vertical\"\n        className=\"m-0.5 flex opacity-0 transition-opacity delay-300 data-[orientation=horizontal]:h-1.5 data-[orientation=vertical]:w-1.5 data-[orientation=horizontal]:flex-col data-hovering:opacity-100 data-scrolling:opacity-100 data-hovering:delay-0 data-scrolling:delay-0 data-hovering:duration-100 data-scrolling:duration-100\"\n      >\n        <ScrollAreaPrimitive.Thumb\n          data-slot=\"scroll-area-thumb\"\n          className=\"relative flex-1 rounded-full bg-foreground/20\"\n        />\n      </ScrollAreaPrimitive.Scrollbar>\n\n      <ConversationScrollButton\n        isAtBottom={isAtBottom}\n        scrollToBottom={scrollToBottom}\n        style={{ bottom: `${scrollButtonOffsetPx}px` }}\n      />\n    </ScrollAreaPrimitive.Root>\n  );\n}\n",
      "type": "registry:component",
      "target": "components/agent/conversation/index.tsx"
    },
    {
      "path": "src/registry/agentstart/conversation/conversation-message.tsx",
      "content": "/* agent-frontmatter:start\nAGENT: Conversation message renderer\nPURPOSE: Render individual user and assistant messages with actions and content\nUSAGE: Import and use in conversation views to display message bubbles\nEXPORTS: ConversationMessage, ConversationMessageProps\nFEATURES:\n  - Renders user messages with image attachments and text\n  - Renders assistant messages with tool parts and streaming\n  - Includes message actions (copy, retry, timestamp)\n  - Handles source citations display\nSEARCHABLE: conversation message, message renderer, user message, assistant message\nagent-frontmatter:end */\n\n\"use client\";\n\nimport {\n  ArrowsClockwiseIcon,\n  CheckIcon,\n  CopyIcon,\n} from \"@phosphor-icons/react\";\nimport type { AgentStartUIMessage } from \"agentstart/agent\";\nimport { type AgentStore, useAgentStartContext } from \"agentstart/client\";\nimport { isToolUIPart } from \"ai\";\nimport { useCallback, useEffect, useRef, useState } from \"react\";\nimport { Avatar, AvatarFallback, AvatarImage } from \"@/components/ui/avatar\";\nimport { Button } from \"@/components/ui/button\";\nimport { cn } from \"@/lib/utils\";\nimport { Message, MessageContent } from \"../message\";\nimport { RelativeTime } from \"../relative-time\";\nimport { Response } from \"../response\";\nimport { Source, Sources, SourcesContent, SourcesTrigger } from \"../sources\";\nimport { MessagePart } from \"../tools/message-part-view\";\n\n// Helper types\ntype MessagePartType = NonNullable<AgentStartUIMessage[\"parts\"]>[number];\ntype TextPart = MessagePartType & { type: \"text\"; text: string };\ntype ImagePart = MessagePartType & {\n  type: \"file\";\n  url: string;\n  mediaType: string;\n  filename?: string;\n};\n\n// Type guards\nconst isTextPart = (part: MessagePartType): part is TextPart =>\n  part?.type === \"text\" &&\n  typeof part.text === \"string\" &&\n  part.text.length > 0;\n\nconst isImagePart = (part: MessagePartType): part is ImagePart =>\n  part?.type === \"file\" &&\n  typeof part.mediaType === \"string\" &&\n  (part.mediaType?.startsWith(\"image/\") ?? false) &&\n  typeof part.url === \"string\" &&\n  (part.url?.length ?? 0) > 0;\n\nconst copyMessageText = (message: AgentStartUIMessage): void => {\n  const parts = message.parts ?? [];\n  if (parts.length === 0) return;\n\n  const contentParts: string[] = [];\n  const sources: Array<{ url: string; title?: string }> = [];\n\n  for (const part of parts) {\n    // Text content\n    if (part.type === \"text\" && part.text) {\n      contentParts.push(part.text);\n    }\n    // Reasoning blocks\n    else if (part.type === \"reasoning\" && part.text) {\n      contentParts.push(`[Thinking]\\n${part.text}`);\n    }\n    // Tool executions\n    else if (isToolUIPart(part)) {\n      const toolName = part.type.replace(\"tool-\", \"\");\n      let toolSection = `[Tool: ${toolName}]`;\n\n      // Format tool input based on type\n      if (part.input) {\n        if (part.type === \"tool-bash\" && part.input.command) {\n          toolSection += `\\nCommand: ${part.input.command}`;\n        } else if (part.type === \"tool-read\" && part.input.filePath) {\n          toolSection += `\\nFile: ${part.input.filePath}`;\n        } else if (part.type === \"tool-write\" && part.input.filePath) {\n          toolSection += `\\nFile: ${part.input.filePath}`;\n        } else if (part.type === \"tool-edit\" && part.input.filePath) {\n          toolSection += `\\nFile: ${part.input.filePath}`;\n        } else if (part.type === \"tool-glob\" && part.input.pattern) {\n          toolSection += `\\nPattern: ${part.input.pattern}`;\n        } else if (part.type === \"tool-grep\" && part.input.pattern) {\n          toolSection += `\\nPattern: ${part.input.pattern}`;\n        } else if (part.type === \"tool-ls\" && part.input.path) {\n          toolSection += `\\nPath: ${part.input.path}`;\n        } else {\n          // Generic fallback for other tools\n          toolSection += `\\nInput: ${JSON.stringify(part.input)}`;\n        }\n      }\n\n      // Format tool output\n      if (part.output?.metadata) {\n        if (part.type === \"tool-bash\") {\n          if (part.output.metadata.stdout)\n            toolSection += `\\nOutput:\\n${part.output.metadata.stdout}`;\n          if (part.output.metadata.stderr)\n            toolSection += `\\nError:\\n${part.output.metadata.stderr}`;\n        } else if (part.type === \"tool-read\" && part.output.metadata.content) {\n          toolSection += `\\nContent:\\n${part.output.metadata.content}`;\n        } else if (\n          part.type === \"tool-grep\" &&\n          (part.output.metadata.files ||\n            part.output.metadata.matches ||\n            part.output.metadata.counts)\n        ) {\n          if (part.output.metadata.files) {\n            toolSection += `\\nFiles:\\n${part.output.metadata.files.join(\"\\n\")}`;\n          } else if (part.output.metadata.matches) {\n            toolSection += `\\nMatches:\\n${part.output.metadata.matches.join(\"\\n\")}`;\n          } else if (part.output.metadata.counts) {\n            toolSection += `\\nCounts:\\n${part.output.metadata.counts.map((c: any) => `${c.filename}: ${c.count}`).join(\"\\n\")}`;\n          }\n        } else if (part.type === \"tool-glob\" && part.output.metadata.matches) {\n          toolSection += `\\nMatches:\\n${part.output.metadata.matches.join(\"\\n\")}`;\n        } else if (part.output.prompt) {\n          toolSection += `\\nResult: ${part.output.prompt}`;\n        }\n      } else if (part.output?.prompt) {\n        toolSection += `\\nResult: ${part.output.prompt}`;\n      }\n\n      contentParts.push(toolSection);\n    }\n    // Source URLs\n    else if (part.type === \"source-url\") {\n      const sourcePart = part;\n      sources.push({\n        url: sourcePart.url,\n        title: sourcePart.title,\n      });\n    }\n  }\n\n  // Add sources at the end\n  if (sources.length > 0) {\n    const sourceLines = sources.map((s) => `- [${s.title || s.url}](${s.url})`);\n    contentParts.push(`\\nSources:\\n${sourceLines.join(\"\\n\")}`);\n  }\n\n  if (contentParts.length === 0) return;\n\n  const fullText = contentParts.join(\"\\n\\n\");\n  void navigator.clipboard.writeText(fullText);\n};\n\ntype CopyButtonProps = {\n  onCopy: () => void;\n  feedbackDuration?: number;\n  className?: string;\n  size?: \"icon-sm\" | \"sm\" | \"default\" | \"lg\" | \"icon\";\n  variant?:\n    | \"ghost\"\n    | \"default\"\n    | \"destructive\"\n    | \"outline\"\n    | \"secondary\"\n    | \"link\";\n};\n\nconst CopyButton = ({\n  onCopy,\n  feedbackDuration = 3000,\n  className,\n  size,\n  variant,\n}: CopyButtonProps) => {\n  const [isCopied, setIsCopied] = useState(false);\n  const timeoutRef = useRef<NodeJS.Timeout | null>(null);\n\n  useEffect(() => {\n    return () => {\n      if (timeoutRef.current) {\n        clearTimeout(timeoutRef.current);\n      }\n    };\n  }, []);\n\n  const handleClick = () => {\n    if (timeoutRef.current) {\n      clearTimeout(timeoutRef.current);\n    }\n\n    onCopy();\n    setIsCopied(true);\n\n    timeoutRef.current = setTimeout(() => {\n      setIsCopied(false);\n      timeoutRef.current = null;\n    }, feedbackDuration);\n  };\n\n  return (\n    <Button\n      onClick={handleClick}\n      disabled={isCopied}\n      className={className}\n      size={size}\n      variant={variant}\n    >\n      {isCopied ? (\n        <CheckIcon className=\"size-4\" weight=\"bold\" />\n      ) : (\n        <CopyIcon className=\"size-4\" weight=\"duotone\" />\n      )}\n      <span className=\"sr-only\">{isCopied ? \"Copied\" : \"Copy\"}</span>\n    </Button>\n  );\n};\n\nexport type ConversationMessageProps = {\n  message: AgentStartUIMessage;\n  isLastMessage: boolean;\n  status: AgentStore<AgentStartUIMessage>[\"status\"];\n  regenerate: AgentStore<AgentStartUIMessage>[\"regenerate\"];\n};\n\nexport function ConversationMessage({\n  message,\n  isLastMessage,\n  status,\n  regenerate,\n}: ConversationMessageProps) {\n  const { threadId, config } = useAgentStartContext();\n\n  const logo = config?.logo;\n  const logoSrc = typeof logo === \"string\" ? logo : logo?.src;\n  const logoAlt = typeof logo === \"string\" ? \"Logo\" : logo?.alt || \"Logo\";\n  const logoWidth = typeof logo === \"string\" ? undefined : logo?.width;\n  const logoHeight = typeof logo === \"string\" ? undefined : logo?.height;\n  const renderAssistantMessage = useCallback(\n    (message: AgentStartUIMessage, isLastMessage: boolean) => {\n      const parts = message.parts ?? [];\n      const elements: React.ReactElement[] = [];\n\n      // Render logo if configured\n      if (logoSrc) {\n        // Generate fallback initials from logoAlt\n        const fallbackText = logoAlt\n          .split(\" \")\n          .map((word) => word[0])\n          .join(\"\")\n          .slice(0, 2)\n          .toUpperCase();\n\n        if (parts.length > 0) {\n          // Logo with content: left-right layout\n          elements.push(\n            <div key=\"logo-header\" className=\"flex flex-col items-start gap-3\">\n              <div className=\"shrink-0\">\n                <Avatar style={{ width: logoWidth, height: logoHeight }}>\n                  <AvatarImage src={logoSrc} alt={logoAlt} />\n                  <AvatarFallback>{fallbackText}</AvatarFallback>\n                </Avatar>\n              </div>\n              <div className=\"flex-1 space-y-2\">\n                {parts.map((part, index) => (\n                  <MessagePart\n                    key={`${message.id}-tool-${index}`}\n                    part={part}\n                    isStreaming={\n                      isLastMessage &&\n                      status === \"streaming\" &&\n                      index === parts.length - 1\n                    }\n                  />\n                ))}\n              </div>\n            </div>,\n          );\n        } else {\n          // Logo only: standalone display\n          elements.push(\n            <div key=\"logo-only\" className=\"flex justify-start\">\n              <Avatar className=\"size-12\">\n                <AvatarImage\n                  src={logoSrc}\n                  alt={logoAlt}\n                  width={logoWidth}\n                  height={logoHeight}\n                />\n                <AvatarFallback>{fallbackText}</AvatarFallback>\n              </Avatar>\n            </div>,\n          );\n        }\n      } else {\n        // Regular rendering without logo\n        elements.push(\n          ...parts.map((part, index) => (\n            <MessagePart\n              key={`${message.id}-tool-${index}`}\n              part={part}\n              isStreaming={\n                isLastMessage &&\n                status === \"streaming\" &&\n                index === parts.length - 1\n              }\n            />\n          )),\n        );\n      }\n\n      return elements;\n    },\n    [status, logoSrc, logoAlt, logoWidth, logoHeight],\n  );\n\n  const renderUserMessage = useCallback((message: AgentStartUIMessage) => {\n    const parts = (message.parts ?? []) as MessagePartType[];\n    const textParts = parts.filter(isTextPart);\n    const imageParts = parts.filter(isImagePart);\n\n    if (textParts.length === 0 && imageParts.length === 0) {\n      return null;\n    }\n\n    return (\n      <div className=\"flex w-full flex-col gap-2\">\n        {imageParts.length > 0 ? (\n          <div\n            className={cn(\n              \"grid gap-2\",\n              imageParts.length === 1 ? \"grid-cols-1\" : \"grid-cols-2\",\n            )}\n          >\n            {imageParts.map((part, index) => (\n              <figure\n                key={`${message.id}-image-${index}`}\n                className=\"relative overflow-hidden rounded-md border bg-muted\"\n              >\n                <img\n                  alt={part.filename || `Attachment ${index + 1}`}\n                  className=\"h-full max-h-60 w-full object-cover\"\n                  loading=\"lazy\"\n                  src={part.url}\n                />\n                {part.filename ? (\n                  <figcaption className=\"sr-only\">{part.filename}</figcaption>\n                ) : null}\n              </figure>\n            ))}\n          </div>\n        ) : null}\n\n        {textParts.map((part, index) => (\n          <Response key={`${message.id}-text-${index}`}>{part.text}</Response>\n        ))}\n      </div>\n    );\n  }, []);\n\n  const renderUserActions = (message: AgentStartUIMessage) => (\n    <div className=\"flex items-center gap-1 opacity-0 group-hover:opacity-100\">\n      <CopyButton\n        className=\"size-7\"\n        size=\"icon-sm\"\n        variant=\"ghost\"\n        onCopy={() => copyMessageText(message)}\n      />\n\n      <RelativeTime timestamp={message.metadata?.createdAt} />\n    </div>\n  );\n\n  const renderAssistantActions = (message: AgentStartUIMessage) => {\n    const parts = message.parts ?? [];\n    const sourceParts = parts.filter((part) => part.type === \"source-url\");\n\n    return (\n      <>\n        <div className=\"flex w-full items-center justify-start gap-1 opacity-0 group-hover:opacity-100\">\n          <Button\n            className=\"size-7\"\n            size=\"icon-sm\"\n            variant=\"ghost\"\n            onClick={() =>\n              regenerate({\n                body: {\n                  threadId,\n                },\n              })\n            }\n          >\n            <ArrowsClockwiseIcon className=\"size-4\" weight=\"duotone\" />\n            <span className=\"sr-only\">Retry</span>\n          </Button>\n\n          <CopyButton\n            className=\"size-7\"\n            size=\"icon-sm\"\n            variant=\"ghost\"\n            onCopy={() => copyMessageText(message)}\n          />\n\n          <RelativeTime timestamp={message.metadata?.createdAt} />\n        </div>\n\n        {sourceParts.length > 0 && (\n          <div className=\"w-full\">\n            <Sources>\n              <SourcesTrigger count={sourceParts.length} />\n              <SourcesContent>\n                {sourceParts.map((part, index) => {\n                  return (\n                    <Source\n                      key={`${message.id}-source-${index}`}\n                      href={part.url}\n                      title={part.title || part.url}\n                    />\n                  );\n                })}\n              </SourcesContent>\n            </Sources>\n          </div>\n        )}\n      </>\n    );\n  };\n\n  if (message.role === \"system\") {\n    return null;\n  }\n\n  return (\n    <Message\n      from={message.role}\n      key={message.id}\n      className={cn(\"flex-col\", {\n        \"items-start\": message.role === \"assistant\",\n        \"items-end\": message.role === \"user\",\n      })}\n    >\n      {message.role === \"user\" && renderUserActions(message)}\n\n      <MessageContent\n        className={cn({\n          \"space-y-2\": message.role === \"assistant\",\n          \"mb-2\": message.role === \"user\",\n          \"text-base ltr:rounded-br-none! rtl:rounded-bl-none!\":\n            message.role === \"user\",\n        })}\n        variant={message.role === \"assistant\" ? \"flat\" : \"contained\"}\n      >\n        {message.role === \"assistant\"\n          ? renderAssistantMessage(message, isLastMessage)\n          : renderUserMessage(message)}\n      </MessageContent>\n\n      {message.role === \"assistant\" && [\"ready\", \"error\"].includes(status)\n        ? renderAssistantActions(message)\n        : null}\n    </Message>\n  );\n}\n",
      "type": "registry:component",
      "target": "components/agent/conversation/conversation-message.tsx"
    }
  ]
}