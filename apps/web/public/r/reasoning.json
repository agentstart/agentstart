{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "reasoning",
  "type": "registry:component",
  "title": "AgentStart Reasoning",
  "description": "Reasoning disclosure widget that shows expandable reasoning traces with streaming-aware behavior. Auto-opens while streaming and auto-closes after completion.",
  "dependencies": [
    "@phosphor-icons/react",
    "@shikijs/transformers",
    "agentstart",
    "motion",
    "react",
    "react-medium-image-zoom",
    "shiki",
    "streamdown"
  ],
  "registryDependencies": [],
  "files": [
    {
      "path": "src/registry/agentstart/tools/reasoning.tsx",
      "content": "/* agent-frontmatter:start\nAGENT: Reasoning disclosure widget\nPURPOSE: Show expandable reasoning traces with streaming-aware behavior\nUSAGE: import { Reasoning, ReasoningTrigger, ReasoningContent } from \\\"@/components/agent/reasoning\\\"\nEXPORTS: Reasoning, ReasoningTrigger, ReasoningContent\nFEATURES:\n  - Auto-opens while streaming and auto-closes after completion\n  - Displays duration summaries and shimmer placeholder\nSEARCHABLE: reasoning panel, collapsible thinking, agent reasoning ui\nagent-frontmatter:end */\n\n\"use client\";\n\nimport { BrainIcon, CaretDownIcon } from \"@phosphor-icons/react\";\nimport type { ComponentProps } from \"react\";\nimport { createContext, memo, useContext, useEffect, useState } from \"react\";\n\n// Simple implementation of useControllableState for Base UI compatibility\nfunction useControllableState<T>({\n  prop,\n  defaultProp,\n  onChange,\n}: {\n  prop?: T;\n  defaultProp: T;\n  onChange?: (value: T) => void;\n}) {\n  const [state, setState] = useState(prop ?? defaultProp);\n\n  useEffect(() => {\n    if (prop !== undefined) {\n      setState(prop);\n    }\n  }, [prop]);\n\n  const setValue = (value: T) => {\n    if (prop === undefined) {\n      setState(value);\n    }\n    onChange?.(value);\n  };\n\n  return [state, setValue] as const;\n}\n\nimport { cn } from \"@/lib/utils\";\nimport { Response } from \"../response\";\nimport { Shimmer } from \"../shimmer\";\nimport { Steps, StepsContent, StepsItem, StepsTrigger } from \"../steps\";\n\ntype ReasoningContextValue = {\n  isStreaming: boolean;\n  isOpen: boolean;\n  setIsOpen: (open: boolean) => void;\n  duration: number;\n};\n\nconst ReasoningContext = createContext<ReasoningContextValue | null>(null);\n\nconst useReasoning = () => {\n  const context = useContext(ReasoningContext);\n  if (!context) {\n    throw new Error(\"Reasoning components must be used within Reasoning\");\n  }\n  return context;\n};\n\nexport type ReasoningProps = ComponentProps<typeof Steps> & {\n  isStreaming?: boolean;\n  open?: boolean;\n  defaultOpen?: boolean;\n  onOpenChange?: (open: boolean) => void;\n  duration?: number;\n};\n\nconst AUTO_CLOSE_DELAY = 1000;\nconst MS_IN_S = 1000;\n\nexport const Reasoning = memo(\n  ({\n    className,\n    isStreaming = false,\n    open,\n    defaultOpen = true,\n    onOpenChange,\n    duration: durationProp,\n    children,\n    ...props\n  }: ReasoningProps) => {\n    const [isOpen, setIsOpen] = useControllableState({\n      prop: open,\n      defaultProp: defaultOpen,\n      onChange: onOpenChange,\n    });\n    const [duration, setDuration] = useControllableState({\n      prop: durationProp,\n      defaultProp: 0,\n    });\n\n    const [hasAutoClosed, setHasAutoClosed] = useState(false);\n    const [startTime, setStartTime] = useState<number | null>(null);\n\n    // Track duration when streaming starts and ends\n    useEffect(() => {\n      if (isStreaming) {\n        if (startTime === null) {\n          setStartTime(Date.now());\n        }\n      } else if (startTime !== null) {\n        setDuration(Math.ceil((Date.now() - startTime) / MS_IN_S));\n        setStartTime(null);\n      }\n    }, [isStreaming, startTime, setDuration]);\n\n    // Auto-open when streaming starts, auto-close when streaming ends (once only)\n    useEffect(() => {\n      if (defaultOpen && !isStreaming && isOpen && !hasAutoClosed) {\n        // Add a small delay before closing to allow user to see the content\n        const timer = setTimeout(() => {\n          setIsOpen(false);\n          setHasAutoClosed(true);\n        }, AUTO_CLOSE_DELAY);\n\n        return () => clearTimeout(timer);\n      }\n    }, [isStreaming, isOpen, defaultOpen, setIsOpen, hasAutoClosed]);\n\n    const handleOpenChange = (newOpen: boolean) => {\n      setIsOpen(newOpen);\n    };\n\n    return (\n      <ReasoningContext.Provider\n        value={{ isStreaming, isOpen, setIsOpen, duration }}\n      >\n        <Steps\n          data-tool-reasoning\n          className={cn(\"not-prose\", className)}\n          onOpenChange={handleOpenChange}\n          open={isOpen}\n          {...props}\n        >\n          {children}\n        </Steps>\n      </ReasoningContext.Provider>\n    );\n  },\n);\n\nexport type ReasoningTriggerProps = ComponentProps<typeof StepsTrigger>;\n\nexport const getThinkingMessage = (isStreaming: boolean, duration?: number) => {\n  if (isStreaming || duration === 0) {\n    return <Shimmer duration={1}>Thinking...</Shimmer>;\n  }\n  if (duration === undefined) {\n    return <p>Thought for a few seconds</p>;\n  }\n  return <p>Thought for {duration} seconds</p>;\n};\n\nexport const ReasoningTrigger = memo(\n  ({ className, children, ...props }: ReasoningTriggerProps) => {\n    const { isStreaming, isOpen, duration } = useReasoning();\n\n    return (\n      <StepsTrigger\n        leftIcon={<BrainIcon className=\"size-4\" weight=\"duotone\" />}\n        loading={isStreaming}\n        className={cn(\n          \"flex w-full items-center gap-2 text-muted-foreground text-sm transition-colors hover:text-foreground\",\n          className,\n        )}\n        {...props}\n      >\n        {children ?? (\n          <>\n            {getThinkingMessage(isStreaming, duration)}\n            <CaretDownIcon\n              className={cn(\n                \"size-4 transition-transform\",\n                isOpen ? \"rotate-180\" : \"rotate-0\",\n              )}\n            />\n          </>\n        )}\n      </StepsTrigger>\n    );\n  },\n);\n\nexport type ReasoningContentProps = ComponentProps<typeof StepsContent> & {\n  children: string;\n};\n\nexport const ReasoningContent = memo(\n  ({ className, children, ...props }: ReasoningContentProps) => (\n    <StepsContent\n      className={cn(\n        \"data-[state=closed]:fade-out-0 data-[state=closed]:slide-out-to-top-2 data-[state=open]:slide-in-from-top-2 text-muted-foreground text-sm outline-none data-[state=closed]:animate-out data-[state=open]:animate-in\",\n        className,\n      )}\n      {...props}\n    >\n      <StepsItem>\n        <Response className=\"grid gap-2\">{children}</Response>\n      </StepsItem>\n    </StepsContent>\n  ),\n);\n\nReasoning.displayName = \"Reasoning\";\nReasoningTrigger.displayName = \"ReasoningTrigger\";\nReasoningContent.displayName = \"ReasoningContent\";\n",
      "type": "registry:component",
      "target": "components/agent/tools/reasoning.tsx"
    },
    {
      "path": "src/registry/agentstart/steps.tsx",
      "content": "\"use client\";\n\nimport { CaretRightIcon, WarningCircleIcon } from \"@phosphor-icons/react\";\nimport {\n  Collapsible,\n  CollapsibleContent,\n  CollapsibleTrigger,\n} from \"@/components/ui/collapsible\";\nimport { ScrollArea } from \"@/components/ui/scroll-area\";\nimport { Spinner } from \"@/components/ui/spinner\";\nimport { cn } from \"@/lib/utils\";\n\nexport type StepsItemProps = React.ComponentProps<\"div\">;\n\nexport const StepsItem = ({\n  children,\n  className,\n  ...props\n}: StepsItemProps) => (\n  <div className={cn(\"text-muted-foreground text-sm\", className)} {...props}>\n    {children}\n  </div>\n);\n\nexport type StepsTriggerProps = React.ComponentProps<\n  typeof CollapsibleTrigger\n> & {\n  leftIcon?: React.ReactNode;\n  swapIconOnHover?: boolean;\n  loading?: boolean;\n  error?: boolean;\n};\n\nexport const StepsTrigger = ({\n  children,\n  className,\n  leftIcon,\n  swapIconOnHover = true,\n  loading = false,\n  error = false,\n  ...props\n}: StepsTriggerProps) => {\n  const iconNode = loading ? (\n    <Spinner className=\"size-4 text-muted-foreground\" />\n  ) : error ? (\n    <WarningCircleIcon weight=\"duotone\" className=\"size-4 text-red-600\" />\n  ) : (\n    leftIcon\n  );\n  const shouldSwapIconOnHover = swapIconOnHover && !loading && !error;\n\n  return (\n    <CollapsibleTrigger\n      className={cn(\n        \"group/steps-trigger flex w-full cursor-pointer items-center justify-start gap-1 text-muted-foreground text-sm transition-colors hover:text-foreground\",\n        className,\n      )}\n      aria-busy={loading || undefined}\n      {...props}\n    >\n      <div className=\"flex w-full items-center gap-2\">\n        {iconNode ? (\n          <span className=\"relative inline-flex size-4 items-center justify-center\">\n            <span\n              className={cn(\n                \"transition-opacity\",\n                shouldSwapIconOnHover && \"group-hover/steps-trigger:opacity-0\",\n              )}\n            >\n              {iconNode}\n            </span>\n            {shouldSwapIconOnHover && (\n              <CaretRightIcon className=\"absolute size-4 opacity-0 transition-all group-hover/steps-trigger:opacity-100 group-data-panel-open/steps-trigger:rotate-90\" />\n            )}\n          </span>\n        ) : null}\n        {children}\n      </div>\n      {!iconNode &&\n        (loading ? (\n          <Spinner className=\"size-4 text-muted-foreground\" />\n        ) : (\n          <CaretRightIcon className=\"size-4 transition-transform group-data-panel-open/steps-trigger:rotate-90\" />\n        ))}\n    </CollapsibleTrigger>\n  );\n};\n\nexport type StepsContentProps = React.ComponentProps<\n  typeof CollapsibleContent\n> & {\n  bar?: React.ReactNode;\n};\n\nexport const StepsContent = ({\n  children,\n  className,\n  bar,\n  ...props\n}: StepsContentProps) => {\n  return (\n    <CollapsibleContent\n      className={cn(\n        \"overflow-hidden text-popover-foreground data-[state=closed]:animate-collapsible-up data-[state=open]:animate-collapsible-down\",\n        className,\n      )}\n      {...props}\n    >\n      <ScrollArea className=\"mt-3 grid max-h-96 min-w-0 max-w-full grid-cols-[min-content_minmax(0,1fr)] items-start gap-x-3 overflow-y-auto\">\n        <div className=\"min-w-0 self-stretch\">{bar ?? <StepsBar />}</div>\n        <div className=\"min-w-0 space-y-2\">{children}</div>\n      </ScrollArea>\n    </CollapsibleContent>\n  );\n};\n\nexport type StepsBarProps = React.HTMLAttributes<HTMLDivElement>;\n\nexport const StepsBar = ({ className, ...props }: StepsBarProps) => (\n  <div\n    className={cn(\"mr-2 ml-1.5 h-full w-[2px] bg-muted\", className)}\n    aria-hidden\n    {...props}\n  />\n);\n\nexport type StepsProps = React.ComponentProps<typeof Collapsible>;\n\nexport function Steps({\n  defaultOpen = false,\n  className,\n  ...props\n}: StepsProps) {\n  return (\n    <Collapsible\n      className={cn(className)}\n      defaultOpen={defaultOpen}\n      {...props}\n    />\n  );\n}\n",
      "type": "registry:component",
      "target": "components/agent/steps.tsx"
    },
    {
      "path": "src/registry/agentstart/shimmer.tsx",
      "content": "/* agent-frontmatter:start\nAGENT: Shimmer loading indicators\nPURPOSE: Animated loading states with randomized text and configurable effects\nUSAGE: <Shimmer duration={2}>Loading...</Shimmer> or <StatusIndicators randomText />\nEXPORTS: Shimmer, StatusIndicators\nFEATURES:\n  - Animated gradient shimmer with configurable duration and spread\n  - StatusIndicators with randomized action words\n  - Multiple animation variants (fade, slide, blur-fade)\n  - Motion-based smooth transitions\nSEARCHABLE: shimmer, loading animation, status indicator, animated loader\nagent-frontmatter:end */\n\n\"use client\";\n\nimport { AnimatePresence, motion } from \"motion/react\";\nimport {\n  type CSSProperties,\n  type ElementType,\n  type JSX,\n  memo,\n  type ReactNode,\n  useMemo,\n} from \"react\";\nimport { cn } from \"@/lib/utils\";\n\nexport interface ShimmerProps {\n  children: string;\n  as?: ElementType;\n  className?: string;\n  duration?: number;\n  spread?: number;\n}\n\nexport const Shimmer = memo<ShimmerProps>(\n  ({ children, as: Component = \"p\", className, duration = 2, spread = 2 }) => {\n    const MotionComponent = motion.create(\n      Component as keyof JSX.IntrinsicElements,\n    );\n\n    const dynamicSpread = useMemo(\n      () => (children?.length ?? 0) * spread,\n      [children, spread],\n    );\n\n    return (\n      <MotionComponent\n        animate={{ backgroundPosition: \"0% center\" }}\n        className={cn(\n          \"relative inline-block bg-size-[250%_100%,auto] bg-clip-text text-transparent\",\n          \"[--bg:linear-gradient(90deg,#0000_calc(50%-var(--spread)),var(--color-background),#0000_calc(50%+var(--spread)))] [background-repeat:no-repeat,padding-box]\",\n          className,\n        )}\n        initial={{ backgroundPosition: \"100% center\" }}\n        style={\n          {\n            \"--spread\": `${dynamicSpread}px`,\n            backgroundImage:\n              \"var(--bg), linear-gradient(var(--color-muted-foreground), var(--color-muted-foreground))\",\n          } as CSSProperties\n        }\n        transition={{\n          repeat: Number.POSITIVE_INFINITY,\n          duration,\n          ease: \"linear\",\n        }}\n      >\n        {children}\n      </MotionComponent>\n    );\n  },\n);\n\nconst words = [\n  \"Accomplishing\",\n  \"Actioning\",\n  \"Actualizing\",\n  \"Baking\",\n  \"Booping\",\n  \"Brewing\",\n  \"Calculating\",\n  \"Cerebrating\",\n  \"Channelling\",\n  \"Churning\",\n  \"Clauding\",\n  \"Coalescing\",\n  \"Cogitating\",\n  \"Computing\",\n  \"Combobulating\",\n  \"Concocting\",\n  \"Considering\",\n  \"Contemplating\",\n  \"Cooking\",\n  \"Crafting\",\n  \"Creating\",\n  \"Crunching\",\n  \"Deciphering\",\n  \"Deliberating\",\n  \"Determining\",\n  \"Discombobulating\",\n  \"Doing\",\n  \"Effecting\",\n  \"Elucidating\",\n  \"Enchanting\",\n  \"Envisioning\",\n  \"Finagling\",\n  \"Flibbertigibbeting\",\n  \"Forging\",\n  \"Forming\",\n  \"Frolicking\",\n  \"Generating\",\n  \"Germinating\",\n  \"Hatching\",\n  \"Herding\",\n  \"Honking\",\n  \"Ideating\",\n  \"Imagining\",\n  \"Incubating\",\n  \"Inferring\",\n  \"Manifesting\",\n  \"Marinating\",\n  \"Meandering\",\n  \"Moseying\",\n  \"Mulling\",\n  \"Mustering\",\n  \"Musing\",\n  \"Noodling\",\n  \"Percolating\",\n  \"Perusing\",\n  \"Philosophising\",\n  \"Pontificating\",\n  \"Pondering\",\n  \"Processing\",\n  \"Puttering\",\n  \"Puzzling\",\n  \"Reticulating\",\n  \"Ruminating\",\n  \"Scheming\",\n  \"Schlepping\",\n  \"Shimmying\",\n  \"Simmering\",\n  \"Smooshing\",\n  \"Spelunking\",\n  \"Spinning\",\n  \"Stewing\",\n  \"Sussing\",\n  \"Synthesizing\",\n  \"Thinking\",\n  \"Tinkering\",\n  \"Transmuting\",\n  \"Unfurling\",\n  \"Unravelling\",\n  \"Vibing\",\n  \"Wandering\",\n  \"Whirring\",\n  \"Wibbling\",\n  \"Working\",\n  \"Wrangling\",\n];\n\nconst animations = {\n  fade: {\n    initial: { opacity: 0 },\n    animate: { opacity: 1 },\n    exit: { opacity: 0 },\n  },\n  slide: {\n    initial: { opacity: 0, x: 10 },\n    animate: { opacity: 1, x: 0 },\n    exit: { opacity: 0, x: -10 },\n  },\n  \"blur-fade\": {\n    initial: { opacity: 0, filter: \"blur(6px)\" },\n    animate: { opacity: 1, filter: \"blur(0px)\" },\n    exit: { opacity: 0, filter: \"blur(6px)\" },\n  },\n};\n\ninterface StatusIndicatorsProps {\n  prefix?: ReactNode;\n  suffix?: ReactNode;\n  text?: string;\n  randomText?: boolean;\n  shimmerDuration?: number;\n  className?: string;\n  fadeDuration?: number;\n  variant?: \"fade\" | \"slide\" | \"blur-fade\";\n}\n\nexport function StatusIndicators({\n  prefix,\n  suffix,\n  text,\n  randomText = true,\n  shimmerDuration = 1,\n  className,\n  fadeDuration = 0.2,\n  variant = \"fade\",\n}: StatusIndicatorsProps) {\n  const selected = animations[variant];\n\n  const displayText = useMemo(() => {\n    if (randomText) {\n      const randomIndex = Math.floor(Math.random() * words.length);\n      return `${words[randomIndex]}...`;\n    }\n    return text;\n  }, [randomText, text]);\n\n  return (\n    <div className=\"relative flex h-8 items-center whitespace-nowrap\">\n      <AnimatePresence mode=\"wait\">\n        {displayText && (\n          <motion.div\n            key={displayText}\n            initial={selected.initial}\n            animate={selected.animate}\n            exit={selected.exit}\n            transition={{\n              duration: fadeDuration,\n              ease: \"easeInOut\",\n            }}\n            className=\"flex items-center gap-1.5 text-muted-foreground dark:text-[#666666]\"\n          >\n            {prefix}\n            <Shimmer className={className} duration={shimmerDuration}>\n              {displayText || \"\"}\n            </Shimmer>\n            {suffix}\n          </motion.div>\n        )}\n      </AnimatePresence>\n    </div>\n  );\n}\n",
      "type": "registry:component",
      "target": "components/agent/shimmer.tsx"
    },
    {
      "path": "src/registry/agentstart/response.tsx",
      "content": "/* agent-frontmatter:start\nAGENT: Markdown response renderer\nPURPOSE: Render assistant text parts using Streamdown with stable memoization\nUSAGE: import { Response } from \\\"@/components/agent/response\\\"\nEXPORTS: Response\nFEATURES:\n  - Applies consistent typography to markdown streams\n  - Memoizes children to avoid unnecessary rerenders\nSEARCHABLE: markdown renderer, streamdown response, agent output\nagent-frontmatter:end */\n\n\"use client\";\n\nimport {\n  MagnifyingGlassMinusIcon,\n  MagnifyingGlassPlusIcon,\n} from \"@phosphor-icons/react\";\nimport { type ComponentProps, memo } from \"react\";\nimport Zoom from \"react-medium-image-zoom\";\nimport type { BundledLanguage } from \"shiki/bundle/web\";\nimport { Streamdown } from \"streamdown\";\nimport { cn } from \"@/lib/utils\";\nimport { CodeBlock } from \"./code-block\";\nimport \"react-medium-image-zoom/dist/styles.css\";\n\ntype ResponseProps = ComponentProps<typeof Streamdown>;\n\nexport const Response = memo(\n  ({ className, ...props }: ResponseProps) => (\n    <Streamdown\n      className={cn(\n        \"size-full text-base [&>*:first-child]:mt-0 [&>*:last-child]:mb-0\",\n        className,\n      )}\n      components={{\n        pre: ({ children, node, ...props }) => {\n          const [firstChild] = node?.children ?? [];\n\n          if (\n            firstChild &&\n            firstChild.type === \"element\" &&\n            firstChild.tagName === \"code\" &&\n            firstChild.children[0]?.type === \"text\"\n          ) {\n            const { className } = firstChild.properties;\n            const [, language = \"plaintext\"] =\n              /language-(.+)/.exec(String(className) || \"\") ?? [];\n            const code = firstChild.children[0].value.trim();\n\n            return (\n              <pre {...props}>\n                <CodeBlock\n                  className=\"my-4\"\n                  code={code}\n                  language={language as BundledLanguage}\n                />\n              </pre>\n            );\n          }\n\n          const lang = props.className?.split(\"language-\")[1] ?? \"markdown\";\n          return (\n            <pre {...props}>\n              <CodeBlock\n                className=\"my-4\"\n                code={children as string}\n                language={lang as BundledLanguage}\n              />\n            </pre>\n          );\n        },\n        img: (props) => {\n          const { src, alt, ...rest } = props;\n          if (!src) return null;\n          return (\n            <Zoom\n              IconZoom={() => (\n                <MagnifyingGlassPlusIcon\n                  weight=\"duotone\"\n                  className=\"size-5.5\"\n                />\n              )}\n              IconUnzoom={() => (\n                <MagnifyingGlassMinusIcon\n                  weight=\"duotone\"\n                  className=\"size-5.5\"\n                />\n              )}\n            >\n              <img\n                className=\"my-2 block max-h-40 rounded-lg\"\n                src={src}\n                loading=\"lazy\"\n                alt={alt}\n                {...rest}\n              />\n            </Zoom>\n          );\n        },\n      }}\n      {...props}\n    />\n  ),\n  (prevProps, nextProps) => prevProps.children === nextProps.children,\n);\n\nResponse.displayName = \"Response\";\n",
      "type": "registry:component",
      "target": "components/agent/response.tsx"
    },
    {
      "path": "src/registry/agentstart/code-block.tsx",
      "content": "/* agent-frontmatter:start\nAGENT: Code block component with syntax highlighting\nPURPOSE: Render syntax-highlighted code snippets with line numbers and copy functionality\nUSAGE: <CodeBlock code={code} language=\"typescript\" showLineNumbers copyCode={originalCode} />\nEXPORTS: CodeBlock, CodeBlockCopyButton, highlightCode\nFEATURES:\n  - Dual-theme syntax highlighting (light/dark) using Shiki\n  - Optional line number display\n  - Copy-to-clipboard button with success feedback\n  - Separate copyCode prop to copy original content without diff markers\n  - Supports all Shiki bundled languages and diff notation\nSEARCHABLE: code block, syntax highlighting, shiki, copy button, diff\nagent-frontmatter:end */\n\n\"use client\";\n\nimport { CheckIcon, CopyIcon } from \"@phosphor-icons/react\";\nimport { transformerNotationDiff } from \"@shikijs/transformers\";\nimport { useTheme } from \"agentstart/client\";\nimport {\n  type ComponentProps,\n  createContext,\n  type HTMLAttributes,\n  useContext,\n  useEffect,\n  useRef,\n  useState,\n} from \"react\";\nimport {\n  type BundledLanguage,\n  codeToHtml,\n  type ShikiTransformer,\n} from \"shiki/bundle/web\";\nimport { Button } from \"@/components/ui/button\";\nimport { ScrollArea } from \"@/components/ui/scroll-area\";\nimport { cn } from \"@/lib/utils\";\n\ntype CodeBlockProps = HTMLAttributes<HTMLDivElement> & {\n  code: string;\n  language: BundledLanguage;\n  showLineNumbers?: boolean;\n  showCopyButton?: boolean;\n  showDiff?: boolean;\n  /** Original code without diff markers for copying */\n  copyCode?: string;\n};\n\ntype CodeBlockContextType = {\n  code: string;\n  copyCode: string;\n};\n\nconst CodeBlockContext = createContext<CodeBlockContextType>({\n  code: \"\",\n  copyCode: \"\",\n});\n\nconst lineNumberTransformer: ShikiTransformer = {\n  name: \"line-numbers\",\n  line(node, line) {\n    node.children.unshift({\n      type: \"element\",\n      tagName: \"span\",\n      properties: {\n        className: [\n          \"inline-block\",\n          \"min-w-10\",\n          \"mr-4\",\n          \"text-right\",\n          \"select-none\",\n          \"text-muted-foreground\",\n        ],\n      },\n      children: [{ type: \"text\", value: String(line) }],\n    });\n  },\n};\n\nexport async function highlightCode({\n  code,\n  language,\n  showLineNumbers = false,\n  showDiff = false,\n}: {\n  code: string;\n  language: BundledLanguage;\n  showLineNumbers: boolean;\n  showDiff: boolean;\n}) {\n  const transformers: ShikiTransformer[] = [];\n\n  if (showLineNumbers) {\n    transformers.push(lineNumberTransformer);\n  }\n\n  if (showDiff) {\n    transformers.push(transformerNotationDiff());\n  }\n\n  return await Promise.all([\n    codeToHtml(code, {\n      lang: language,\n      theme: \"vitesse-light\",\n      transformers,\n    }),\n    codeToHtml(code, {\n      lang: language,\n      theme: \"vesper\",\n      transformers,\n    }),\n  ]);\n}\n\nexport const CodeBlock = ({\n  code,\n  language,\n  showLineNumbers = false,\n  showCopyButton = true,\n  showDiff = false,\n  copyCode,\n  className,\n  children,\n  ...props\n}: CodeBlockProps) => {\n  const [html, setHtml] = useState<string>(\"\");\n  const [darkHtml, setDarkHtml] = useState<string>(\"\");\n  const mounted = useRef(false);\n  const { resolvedTheme } = useTheme();\n\n  useEffect(() => {\n    highlightCode({ code, language, showLineNumbers, showDiff }).then(\n      ([light, dark]) => {\n        if (!mounted.current) {\n          setHtml(light);\n          setDarkHtml(dark);\n          mounted.current = true;\n        }\n      },\n    );\n\n    return () => {\n      mounted.current = false;\n    };\n  }, [code, language, showLineNumbers, showDiff]);\n\n  return (\n    <CodeBlockContext.Provider value={{ code, copyCode: copyCode ?? code }}>\n      <div\n        className={cn(\n          \"group/code-block relative max-h-[200px] overflow-hidden rounded-lg border text-foreground\",\n          \"[&_.diff.add]:bg-green-500/10 [&_.diff.add]:text-green-600 [&_.diff.add]:before:absolute [&_.diff.add]:before:left-1 [&_.diff.add]:before:content-['+']\",\n          \"[&_.diff.remove]:bg-red-500/10 [&_.diff.remove]:text-red-600 [&_.diff.remove]:opacity-70 [&_.diff.remove]:before:absolute [&_.diff.remove]:before:left-1 [&_.diff.remove]:before:content-['-']\",\n          \"dark:[&_.diff.add]:bg-green-500/20 dark:[&_.diff.add]:text-green-400\",\n          \"dark:[&_.diff.remove]:bg-red-500/20 dark:[&_.diff.remove]:text-red-400\",\n          className,\n        )}\n        {...props}\n      >\n        <ScrollArea className=\"max-h-[200px]\">\n          <div\n            className={cn(\n              \"[&>pre]:m-0 [&>pre]:bg-background! [&>pre]:text-foreground! [&>pre]:text-sm\",\n              \"[&_code]:wrap-break-word [&_code]:block [&_code]:w-full [&_code]:border-none [&_code]:font-mono [&_code]:text-sm [&_code]:leading-normal\",\n              \"[&_.line]:relative [&_.line]:inline-block [&_.line]:w-full [&_.line]:px-4\",\n            )}\n            dangerouslySetInnerHTML={{\n              __html: resolvedTheme === \"dark\" ? darkHtml : html,\n            }}\n          />\n          {children && (\n            <div className=\"absolute top-2 right-2 flex items-center gap-2\">\n              {children}\n            </div>\n          )}\n        </ScrollArea>\n        {showCopyButton && (\n          <CodeBlockCopyButton className=\"absolute top-2 right-2 opacity-0 transition-opacity group-hover/code-block:opacity-100\" />\n        )}\n      </div>\n    </CodeBlockContext.Provider>\n  );\n};\n\nexport type CodeBlockCopyButtonProps = ComponentProps<typeof Button> & {\n  onCopy?: () => void;\n  onError?: (error: Error) => void;\n  timeout?: number;\n};\n\nexport const CodeBlockCopyButton = ({\n  onCopy,\n  onError,\n  timeout = 2000,\n  children,\n  className,\n  ...props\n}: CodeBlockCopyButtonProps) => {\n  const [isCopied, setIsCopied] = useState(false);\n  const { copyCode } = useContext(CodeBlockContext);\n\n  const copyToClipboard = async () => {\n    if (typeof window === \"undefined\" || !navigator?.clipboard?.writeText) {\n      onError?.(new Error(\"Clipboard API not available\"));\n      return;\n    }\n\n    try {\n      await navigator.clipboard.writeText(copyCode);\n      setIsCopied(true);\n      onCopy?.();\n      setTimeout(() => setIsCopied(false), timeout);\n    } catch (error) {\n      onError?.(error as Error);\n    }\n  };\n\n  const Icon = isCopied ? (\n    <CheckIcon weight=\"bold\" />\n  ) : (\n    <CopyIcon weight=\"duotone\" />\n  );\n\n  return (\n    <Button\n      className={cn(\"shrink-0\", className)}\n      onClick={copyToClipboard}\n      size=\"icon\"\n      variant=\"ghost\"\n      {...props}\n    >\n      {children ?? Icon}\n    </Button>\n  );\n};\n",
      "type": "registry:component",
      "target": "components/agent/code-block.tsx"
    }
  ]
}