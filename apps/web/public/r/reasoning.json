{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "reasoning",
  "type": "registry:component",
  "title": "AgentStart Reasoning",
  "description": "Reasoning disclosure widget that shows expandable reasoning traces with streaming-aware behavior. Auto-opens while streaming and auto-closes after completion.",
  "dependencies": [
    "@phosphor-icons/react",
    "react"
  ],
  "registryDependencies": [
    "@coss/collapsible",
    "response",
    "shimmer"
  ],
  "files": [
    {
      "path": "src/registry/agentstart/reasoning.tsx",
      "content": "/* agent-frontmatter:start\nAGENT: Reasoning disclosure widget\nPURPOSE: Show expandable reasoning traces with streaming-aware behavior\nUSAGE: import { Reasoning, ReasoningTrigger, ReasoningContent } from \\\"@/components/agent/reasoning\\\"\nEXPORTS: Reasoning, ReasoningTrigger, ReasoningContent\nFEATURES:\n  - Auto-opens while streaming and auto-closes after completion\n  - Displays duration summaries and shimmer placeholder\nSEARCHABLE: reasoning panel, collapsible thinking, agent reasoning ui\nagent-frontmatter:end */\n\n\"use client\";\n\nimport { BrainIcon, CaretDownIcon } from \"@phosphor-icons/react\";\nimport type { ComponentProps } from \"react\";\nimport { createContext, memo, useContext, useEffect, useState } from \"react\";\n\n// Simple implementation of useControllableState for Base UI compatibility\nfunction useControllableState<T>({\n  prop,\n  defaultProp,\n  onChange,\n}: {\n  prop?: T;\n  defaultProp: T;\n  onChange?: (value: T) => void;\n}) {\n  const [state, setState] = useState(prop ?? defaultProp);\n\n  useEffect(() => {\n    if (prop !== undefined) {\n      setState(prop);\n    }\n  }, [prop]);\n\n  const setValue = (value: T) => {\n    if (prop === undefined) {\n      setState(value);\n    }\n    onChange?.(value);\n  };\n\n  return [state, setValue] as const;\n}\n\nimport {\n  Collapsible,\n  CollapsibleContent,\n  CollapsibleTrigger,\n} from \"@/components/ui/collapsible\";\nimport { cn } from \"@/lib/utils\";\nimport { Response } from \"./response\";\nimport { Shimmer } from \"./shimmer\";\n\ntype ReasoningContextValue = {\n  isStreaming: boolean;\n  isOpen: boolean;\n  setIsOpen: (open: boolean) => void;\n  duration: number;\n};\n\nconst ReasoningContext = createContext<ReasoningContextValue | null>(null);\n\nconst useReasoning = () => {\n  const context = useContext(ReasoningContext);\n  if (!context) {\n    throw new Error(\"Reasoning components must be used within Reasoning\");\n  }\n  return context;\n};\n\nexport type ReasoningProps = ComponentProps<typeof Collapsible> & {\n  isStreaming?: boolean;\n  open?: boolean;\n  defaultOpen?: boolean;\n  onOpenChange?: (open: boolean) => void;\n  duration?: number;\n};\n\nconst AUTO_CLOSE_DELAY = 1000;\nconst MS_IN_S = 1000;\n\nexport const Reasoning = memo(\n  ({\n    className,\n    isStreaming = false,\n    open,\n    defaultOpen = true,\n    onOpenChange,\n    duration: durationProp,\n    children,\n    ...props\n  }: ReasoningProps) => {\n    const [isOpen, setIsOpen] = useControllableState({\n      prop: open,\n      defaultProp: defaultOpen,\n      onChange: onOpenChange,\n    });\n    const [duration, setDuration] = useControllableState({\n      prop: durationProp,\n      defaultProp: 0,\n    });\n\n    const [hasAutoClosed, setHasAutoClosed] = useState(false);\n    const [startTime, setStartTime] = useState<number | null>(null);\n\n    // Track duration when streaming starts and ends\n    useEffect(() => {\n      if (isStreaming) {\n        if (startTime === null) {\n          setStartTime(Date.now());\n        }\n      } else if (startTime !== null) {\n        setDuration(Math.ceil((Date.now() - startTime) / MS_IN_S));\n        setStartTime(null);\n      }\n    }, [isStreaming, startTime, setDuration]);\n\n    // Auto-open when streaming starts, auto-close when streaming ends (once only)\n    useEffect(() => {\n      if (defaultOpen && !isStreaming && isOpen && !hasAutoClosed) {\n        // Add a small delay before closing to allow user to see the content\n        const timer = setTimeout(() => {\n          setIsOpen(false);\n          setHasAutoClosed(true);\n        }, AUTO_CLOSE_DELAY);\n\n        return () => clearTimeout(timer);\n      }\n    }, [isStreaming, isOpen, defaultOpen, setIsOpen, hasAutoClosed]);\n\n    const handleOpenChange = (newOpen: boolean) => {\n      setIsOpen(newOpen);\n    };\n\n    return (\n      <ReasoningContext.Provider\n        value={{ isStreaming, isOpen, setIsOpen, duration }}\n      >\n        <Collapsible\n          className={cn(\"not-prose mb-4\", className)}\n          onOpenChange={handleOpenChange}\n          open={isOpen}\n          {...props}\n        >\n          {children}\n        </Collapsible>\n      </ReasoningContext.Provider>\n    );\n  },\n);\n\nexport type ReasoningTriggerProps = ComponentProps<typeof CollapsibleTrigger>;\n\nconst getThinkingMessage = (isStreaming: boolean, duration?: number) => {\n  if (isStreaming || duration === 0) {\n    return <Shimmer duration={1}>Thinking...</Shimmer>;\n  }\n  if (duration === undefined) {\n    return <p>Thought for a few seconds</p>;\n  }\n  return <p>Thought for {duration} seconds</p>;\n};\n\nexport const ReasoningTrigger = memo(\n  ({ className, children, ...props }: ReasoningTriggerProps) => {\n    const { isStreaming, isOpen, duration } = useReasoning();\n\n    return (\n      <CollapsibleTrigger\n        className={cn(\n          \"flex w-full items-center gap-2 text-muted-foreground text-sm transition-colors hover:text-foreground\",\n          className,\n        )}\n        {...props}\n      >\n        {children ?? (\n          <>\n            <BrainIcon className=\"size-4\" weight=\"duotone\" />\n            {getThinkingMessage(isStreaming, duration)}\n            <CaretDownIcon\n              className={cn(\n                \"size-4 transition-transform\",\n                isOpen ? \"rotate-180\" : \"rotate-0\",\n              )}\n            />\n          </>\n        )}\n      </CollapsibleTrigger>\n    );\n  },\n);\n\nexport type ReasoningContentProps = ComponentProps<\n  typeof CollapsibleContent\n> & {\n  children: string;\n};\n\nexport const ReasoningContent = memo(\n  ({ className, children, ...props }: ReasoningContentProps) => (\n    <CollapsibleContent\n      className={cn(\n        \"mt-4 text-sm\",\n        \"data-[state=closed]:fade-out-0 data-[state=closed]:slide-out-to-top-2 data-[state=open]:slide-in-from-top-2 text-muted-foreground outline-none data-[state=closed]:animate-out data-[state=open]:animate-in\",\n        className,\n      )}\n      {...props}\n    >\n      <Response className=\"grid gap-2\">{children}</Response>\n    </CollapsibleContent>\n  ),\n);\n\nReasoning.displayName = \"Reasoning\";\nReasoningTrigger.displayName = \"ReasoningTrigger\";\nReasoningContent.displayName = \"ReasoningContent\";\n",
      "type": "registry:component",
      "target": "components/agent/reasoning.tsx"
    }
  ]
}