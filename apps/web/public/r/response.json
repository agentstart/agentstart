{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "response",
  "type": "registry:component",
  "title": "AgentStart Response",
  "description": "Markdown response renderer that renders assistant text parts using Streamdown with stable memoization. Applies consistent typography to markdown streams.",
  "dependencies": [
    "@phosphor-icons/react",
    "react",
    "react-medium-image-zoom",
    "shiki",
    "streamdown"
  ],
  "registryDependencies": [],
  "files": [
    {
      "path": "src/registry/agentstart/response.tsx",
      "content": "/* agent-frontmatter:start\nAGENT: Markdown response renderer\nPURPOSE: Render assistant text parts using Streamdown with stable memoization\nUSAGE: import { Response } from \\\"@/components/agent/response\\\"\nEXPORTS: Response\nFEATURES:\n  - Applies consistent typography to markdown streams\n  - Memoizes children to avoid unnecessary rerenders\nSEARCHABLE: markdown renderer, streamdown response, agent output\nagent-frontmatter:end */\n\n\"use client\";\n\nimport {\n  MagnifyingGlassMinusIcon,\n  MagnifyingGlassPlusIcon,\n} from \"@phosphor-icons/react\";\nimport { type ComponentProps, memo } from \"react\";\nimport Zoom from \"react-medium-image-zoom\";\nimport type { BundledLanguage } from \"shiki/bundle/web\";\nimport { Streamdown } from \"streamdown\";\nimport { cn } from \"@/lib/utils\";\nimport { CodeBlock } from \"./code-block\";\nimport \"react-medium-image-zoom/dist/styles.css\";\n\ntype ResponseProps = ComponentProps<typeof Streamdown>;\n\nexport const Response = memo(\n  ({ className, ...props }: ResponseProps) => (\n    <Streamdown\n      className={cn(\n        \"size-full text-base [&>*:first-child]:mt-0 [&>*:last-child]:mb-0\",\n        className,\n      )}\n      components={{\n        pre: ({ children, node, ...props }) => {\n          const [firstChild] = node?.children ?? [];\n\n          if (\n            firstChild &&\n            firstChild.type === \"element\" &&\n            firstChild.tagName === \"code\" &&\n            firstChild.children[0]?.type === \"text\"\n          ) {\n            const { className } = firstChild.properties;\n            const [, language = \"plaintext\"] =\n              /language-(.+)/.exec(String(className) || \"\") ?? [];\n            const code = firstChild.children[0].value.trim();\n\n            return (\n              <pre {...props}>\n                <CodeBlock\n                  className=\"my-4\"\n                  code={code}\n                  language={language as BundledLanguage}\n                />\n              </pre>\n            );\n          }\n\n          const lang = props.className?.split(\"language-\")[1] ?? \"markdown\";\n          return (\n            <pre {...props}>\n              <CodeBlock\n                className=\"my-4\"\n                code={children as string}\n                language={lang as BundledLanguage}\n              />\n            </pre>\n          );\n        },\n        img: (props) => {\n          const { src, alt, ...rest } = props;\n          if (!src) return null;\n          return (\n            <Zoom\n              IconZoom={() => (\n                <MagnifyingGlassPlusIcon\n                  weight=\"duotone\"\n                  className=\"size-5.5\"\n                />\n              )}\n              IconUnzoom={() => (\n                <MagnifyingGlassMinusIcon\n                  weight=\"duotone\"\n                  className=\"size-5.5\"\n                />\n              )}\n            >\n              <img\n                className=\"my-2 block max-h-40 rounded-lg\"\n                src={src}\n                loading=\"lazy\"\n                alt={alt}\n                {...rest}\n              />\n            </Zoom>\n          );\n        },\n      }}\n      {...props}\n    />\n  ),\n  (prevProps, nextProps) => prevProps.children === nextProps.children,\n);\n\nResponse.displayName = \"Response\";\n",
      "type": "registry:component",
      "target": "components/agent/response.tsx"
    },
    {
      "path": "src/registry/agentstart/code-block.tsx",
      "content": "/* agent-frontmatter:start\nAGENT: Code block component with syntax highlighting\nPURPOSE: Render syntax-highlighted code snippets with line numbers and copy functionality\nUSAGE: <CodeBlock code={code} language=\"typescript\" showLineNumbers copyCode={originalCode} />\nEXPORTS: CodeBlock, CodeBlockCopyButton, highlightCode\nFEATURES:\n  - Dual-theme syntax highlighting (light/dark) using Shiki\n  - Optional line number display\n  - Copy-to-clipboard button with success feedback\n  - Separate copyCode prop to copy original content without diff markers\n  - Supports all Shiki bundled languages and diff notation\nSEARCHABLE: code block, syntax highlighting, shiki, copy button, diff\nagent-frontmatter:end */\n\n\"use client\";\n\nimport { CheckIcon, CopyIcon } from \"@phosphor-icons/react\";\nimport { transformerNotationDiff } from \"@shikijs/transformers\";\nimport { useTheme } from \"agentstart/client\";\nimport {\n  type ComponentProps,\n  createContext,\n  type HTMLAttributes,\n  useContext,\n  useEffect,\n  useRef,\n  useState,\n} from \"react\";\nimport {\n  type BundledLanguage,\n  codeToHtml,\n  type ShikiTransformer,\n} from \"shiki/bundle/web\";\nimport { Button } from \"@/components/ui/button\";\nimport { ScrollArea } from \"@/components/ui/scroll-area\";\nimport { cn } from \"@/lib/utils\";\n\ntype CodeBlockProps = HTMLAttributes<HTMLDivElement> & {\n  code: string;\n  language: BundledLanguage;\n  showLineNumbers?: boolean;\n  showCopyButton?: boolean;\n  showDiff?: boolean;\n  /** Original code without diff markers for copying */\n  copyCode?: string;\n};\n\ntype CodeBlockContextType = {\n  code: string;\n  copyCode: string;\n};\n\nconst CodeBlockContext = createContext<CodeBlockContextType>({\n  code: \"\",\n  copyCode: \"\",\n});\n\nconst lineNumberTransformer: ShikiTransformer = {\n  name: \"line-numbers\",\n  line(node, line) {\n    node.children.unshift({\n      type: \"element\",\n      tagName: \"span\",\n      properties: {\n        className: [\n          \"inline-block\",\n          \"min-w-10\",\n          \"mr-4\",\n          \"text-right\",\n          \"select-none\",\n          \"text-muted-foreground\",\n        ],\n      },\n      children: [{ type: \"text\", value: String(line) }],\n    });\n  },\n};\n\nexport async function highlightCode({\n  code,\n  language,\n  showLineNumbers = false,\n  showDiff = false,\n}: {\n  code: string;\n  language: BundledLanguage;\n  showLineNumbers: boolean;\n  showDiff: boolean;\n}) {\n  const transformers: ShikiTransformer[] = [];\n\n  if (showLineNumbers) {\n    transformers.push(lineNumberTransformer);\n  }\n\n  if (showDiff) {\n    transformers.push(transformerNotationDiff());\n  }\n\n  return await Promise.all([\n    codeToHtml(code, {\n      lang: language,\n      theme: \"vitesse-light\",\n      transformers,\n    }),\n    codeToHtml(code, {\n      lang: language,\n      theme: \"vesper\",\n      transformers,\n    }),\n  ]);\n}\n\nexport const CodeBlock = ({\n  code,\n  language,\n  showLineNumbers = false,\n  showCopyButton = true,\n  showDiff = false,\n  copyCode,\n  className,\n  children,\n  ...props\n}: CodeBlockProps) => {\n  const [html, setHtml] = useState<string>(\"\");\n  const [darkHtml, setDarkHtml] = useState<string>(\"\");\n  const mounted = useRef(false);\n  const { resolvedTheme } = useTheme();\n\n  useEffect(() => {\n    highlightCode({ code, language, showLineNumbers, showDiff }).then(\n      ([light, dark]) => {\n        if (!mounted.current) {\n          setHtml(light);\n          setDarkHtml(dark);\n          mounted.current = true;\n        }\n      },\n    );\n\n    return () => {\n      mounted.current = false;\n    };\n  }, [code, language, showLineNumbers, showDiff]);\n\n  return (\n    <CodeBlockContext.Provider value={{ code, copyCode: copyCode ?? code }}>\n      <div\n        className={cn(\n          \"group/code-block relative max-h-[200px] overflow-hidden rounded-lg border text-foreground\",\n          \"[&_.diff.add]:bg-green-500/10 [&_.diff.add]:text-green-600 [&_.diff.add]:before:absolute [&_.diff.add]:before:left-1 [&_.diff.add]:before:content-['+']\",\n          \"[&_.diff.remove]:bg-red-500/10 [&_.diff.remove]:text-red-600 [&_.diff.remove]:opacity-70 [&_.diff.remove]:before:absolute [&_.diff.remove]:before:left-1 [&_.diff.remove]:before:content-['-']\",\n          \"dark:[&_.diff.add]:bg-green-500/20 dark:[&_.diff.add]:text-green-400\",\n          \"dark:[&_.diff.remove]:bg-red-500/20 dark:[&_.diff.remove]:text-red-400\",\n          className,\n        )}\n        {...props}\n      >\n        <ScrollArea className=\"max-h-[200px]\">\n          <div\n            className={cn(\n              \"[&>pre]:m-0 [&>pre]:bg-background! [&>pre]:text-foreground! [&>pre]:text-sm\",\n              \"[&_code]:wrap-break-word [&_code]:block [&_code]:w-full [&_code]:border-none [&_code]:font-mono [&_code]:text-sm [&_code]:leading-normal\",\n              \"[&_.line]:relative [&_.line]:inline-block [&_.line]:w-full [&_.line]:px-4\",\n            )}\n            dangerouslySetInnerHTML={{\n              __html: resolvedTheme === \"dark\" ? darkHtml : html,\n            }}\n          />\n          {children && (\n            <div className=\"absolute top-2 right-2 flex items-center gap-2\">\n              {children}\n            </div>\n          )}\n        </ScrollArea>\n        {showCopyButton && (\n          <CodeBlockCopyButton className=\"absolute top-2 right-2 opacity-0 transition-opacity group-hover/code-block:opacity-100\" />\n        )}\n      </div>\n    </CodeBlockContext.Provider>\n  );\n};\n\nexport type CodeBlockCopyButtonProps = ComponentProps<typeof Button> & {\n  onCopy?: () => void;\n  onError?: (error: Error) => void;\n  timeout?: number;\n};\n\nexport const CodeBlockCopyButton = ({\n  onCopy,\n  onError,\n  timeout = 2000,\n  children,\n  className,\n  ...props\n}: CodeBlockCopyButtonProps) => {\n  const [isCopied, setIsCopied] = useState(false);\n  const { copyCode } = useContext(CodeBlockContext);\n\n  const copyToClipboard = async () => {\n    if (typeof window === \"undefined\" || !navigator?.clipboard?.writeText) {\n      onError?.(new Error(\"Clipboard API not available\"));\n      return;\n    }\n\n    try {\n      await navigator.clipboard.writeText(copyCode);\n      setIsCopied(true);\n      onCopy?.();\n      setTimeout(() => setIsCopied(false), timeout);\n    } catch (error) {\n      onError?.(error as Error);\n    }\n  };\n\n  const Icon = isCopied ? (\n    <CheckIcon weight=\"bold\" />\n  ) : (\n    <CopyIcon weight=\"duotone\" />\n  );\n\n  return (\n    <Button\n      className={cn(\"shrink-0\", className)}\n      onClick={copyToClipboard}\n      size=\"icon\"\n      variant=\"ghost\"\n      {...props}\n    >\n      {children ?? Icon}\n    </Button>\n  );\n};\n",
      "type": "registry:component",
      "target": "components/agent/code-block.tsx"
    }
  ]
}