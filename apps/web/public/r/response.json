{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "response",
  "type": "registry:component",
  "title": "AgentStart Response",
  "description": "Markdown response renderer that renders assistant text parts using Streamdown with stable memoization. Applies consistent typography to markdown streams.",
  "dependencies": [
    "react",
    "streamdown"
  ],
  "registryDependencies": [
    "code-block"
  ],
  "files": [
    {
      "path": "src/registry/agentstart/response.tsx",
      "content": "/* agent-frontmatter:start\nAGENT: Markdown response renderer\nPURPOSE: Render assistant text parts using Streamdown with stable memoization\nUSAGE: import { Response } from \\\"@/components/agent/response\\\"\nEXPORTS: Response\nFEATURES:\n  - Applies consistent typography to markdown streams\n  - Memoizes children to avoid unnecessary rerenders\nSEARCHABLE: markdown renderer, streamdown response, agent output\nagent-frontmatter:end */\n\n\"use client\";\n\nimport {\n  MagnifyingGlassMinusIcon,\n  MagnifyingGlassPlusIcon,\n} from \"@phosphor-icons/react\";\nimport { type ComponentProps, memo } from \"react\";\nimport Zoom from \"react-medium-image-zoom\";\nimport type { BundledLanguage } from \"shiki/bundle/web\";\nimport { Streamdown } from \"streamdown\";\nimport { cn } from \"@/lib/utils\";\nimport { CodeBlock } from \"./code-block\";\nimport \"react-medium-image-zoom/dist/styles.css\";\n\ntype ResponseProps = ComponentProps<typeof Streamdown>;\n\nexport const Response = memo(\n  ({ className, ...props }: ResponseProps) => (\n    <Streamdown\n      className={cn(\n        \"size-full text-base [&>*:first-child]:mt-0 [&>*:last-child]:mb-0\",\n        className,\n      )}\n      components={{\n        pre: ({ children, node, ...props }) => {\n          const [firstChild] = node?.children ?? [];\n\n          if (\n            firstChild &&\n            firstChild.type === \"element\" &&\n            firstChild.tagName === \"code\" &&\n            firstChild.children[0]?.type === \"text\"\n          ) {\n            const { className } = firstChild.properties;\n            const [, language = \"plaintext\"] =\n              /language-(.+)/.exec(String(className) || \"\") ?? [];\n            const code = firstChild.children[0].value.trim();\n\n            return (\n              <pre {...props}>\n                <CodeBlock\n                  className=\"my-4\"\n                  code={code}\n                  language={language as BundledLanguage}\n                />\n              </pre>\n            );\n          }\n\n          const lang = props.className?.split(\"language-\")[1] ?? \"markdown\";\n          return (\n            <pre {...props}>\n              <CodeBlock\n                className=\"my-4\"\n                code={children as string}\n                language={lang as BundledLanguage}\n              />\n            </pre>\n          );\n        },\n        img: (props) => {\n          const { src, alt, ...rest } = props;\n          if (!src) return null;\n          return (\n            <Zoom\n              IconZoom={() => (\n                <MagnifyingGlassPlusIcon\n                  weight=\"duotone\"\n                  className=\"size-5.5\"\n                />\n              )}\n              IconUnzoom={() => (\n                <MagnifyingGlassMinusIcon\n                  weight=\"duotone\"\n                  className=\"size-5.5\"\n                />\n              )}\n            >\n              <img\n                className=\"my-2 block max-h-40 rounded-lg\"\n                src={src}\n                loading=\"lazy\"\n                alt={alt}\n                {...rest}\n              />\n            </Zoom>\n          );\n        },\n      }}\n      {...props}\n    />\n  ),\n  (prevProps, nextProps) => prevProps.children === nextProps.children,\n);\n\nResponse.displayName = \"Response\";\n",
      "type": "registry:component",
      "target": "components/agent/response.tsx"
    }
  ]
}