{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "welcome-message",
  "type": "registry:component",
  "title": "AgentStart Welcome Message",
  "description": "Display welcome description and initial suggestions for new conversations with send-on-click behavior.",
  "dependencies": [
    "@agentstart/utils",
    "@phosphor-icons/react",
    "@shikijs/transformers",
    "@tanstack/react-query",
    "agentstart",
    "ai",
    "class-variance-authority",
    "date-fns",
    "motion",
    "react",
    "react-fast-compare",
    "react-medium-image-zoom",
    "shiki",
    "streamdown"
  ],
  "registryDependencies": [
    "@coss/button",
    "@coss/spinner"
  ],
  "files": [
    {
      "path": "src/registry/agentstart/welcome-message.tsx",
      "content": "/* agent-frontmatter:start\nAGENT: Welcome message UI component\nPURPOSE: Display welcome description and initial suggestions for new conversations\nUSAGE: Import and render in conversation empty state to show agent introduction\nEXPORTS: WelcomeMessage, WelcomeMessageProps\nFEATURES:\n  - Fetches welcome configuration from the API\n  - Shows agent description and initial suggestions\n  - Click to send suggestion as new message\n  - Auto-hides when conversation starts\n  - Multi-store support via threadId\nSEARCHABLE: welcome message, initial suggestions, agent intro, empty state\nagent-frontmatter:end */\n\n\"use client\";\n\nimport { ArrowUpRightIcon } from \"@phosphor-icons/react\";\nimport { useMutation, useQueryClient } from \"@tanstack/react-query\";\nimport type { AgentStartUIMessage } from \"agentstart/agent\";\nimport type { AgentStore } from \"agentstart/client\";\nimport {\n  getAgentStore,\n  useAgentStartContext,\n  useAgentStore,\n  useStoreRegistry,\n} from \"agentstart/client\";\nimport { AnimatePresence, motion } from \"motion/react\";\nimport { useMemo, useState } from \"react\";\nimport { Button } from \"@/components/ui/button\";\nimport { Spinner } from \"@/components/ui/spinner\";\nimport { ConversationMessage } from \"./conversation/conversation-message\";\n\ntype UIAgentStore = AgentStore<AgentStartUIMessage>;\n\nexport type WelcomeMessageProps = {\n  className?: string;\n};\n\nexport function WelcomeMessage({ className }: WelcomeMessageProps) {\n  const { orpc, threadId, setThreadId, navigate } = useAgentStartContext();\n  const queryClient = useQueryClient();\n  const storeInstances = useStoreRegistry();\n\n  const storeId = threadId ?? \"default\";\n\n  const sendMessage = useAgentStore<\n    AgentStartUIMessage,\n    UIAgentStore[\"sendMessage\"]\n  >((state) => state.sendMessage, storeId);\n  const messages = useAgentStore<AgentStartUIMessage, AgentStartUIMessage[]>(\n    (state) => state.messages,\n    storeId,\n  );\n  const setNewThreadDraft = useAgentStore((state) => state.setNewThreadDraft);\n  const status = useAgentStore((state) => state.status, storeId);\n\n  const [sendingSuggestion, setSendingSuggestion] = useState<string | null>(\n    null,\n  );\n\n  const createThreadMutation = useMutation(\n    orpc.thread.create.mutationOptions(),\n  );\n\n  const isLoading =\n    status === \"submitted\" ||\n    status === \"streaming\" ||\n    createThreadMutation?.isPending;\n\n  // Use config from context (fetched once at provider level)\n  const { config: appConfig } = useAgentStartContext();\n\n  const handleSuggestionClick = async (suggestion: string) => {\n    setSendingSuggestion(suggestion);\n\n    // If no threadId (on homepage), create thread first\n    if (!threadId) {\n      try {\n        const trimmedText = suggestion.trim();\n        setNewThreadDraft({\n          text: trimmedText,\n        });\n\n        const { threadId: newThreadId } =\n          await createThreadMutation.mutateAsync({\n            visibility: \"public\",\n          });\n\n        // Update context state (single source of truth)\n        setThreadId(newThreadId);\n\n        queryClient.invalidateQueries(\n          orpc.thread.list.queryOptions({ input: {} }),\n        );\n\n        navigate(`/thread/${newThreadId}`);\n\n        const newStore = getAgentStore(storeInstances, newThreadId);\n        newStore.getState().sendMessage(\n          { text: suggestion },\n          {\n            body: {\n              threadId: newThreadId,\n            },\n          },\n        );\n      } catch (error) {\n        console.error(\"[WelcomeMessage] Failed to create thread:\", error);\n      } finally {\n        setSendingSuggestion(null);\n      }\n    } else {\n      // Has threadId, send message directly\n      try {\n        navigate(`/thread/${threadId}`);\n        await sendMessage(\n          { text: suggestion },\n          {\n            body: {\n              threadId,\n            },\n          },\n        );\n      } finally {\n        setSendingSuggestion(null);\n      }\n    }\n  };\n\n  const welcomeConfig = appConfig?.welcome;\n  const logo = appConfig?.logo;\n\n  const hasLogo = Boolean(logo);\n  const hasDescription = Boolean(welcomeConfig?.description);\n  const hasSuggestions =\n    Boolean(welcomeConfig?.suggestions) &&\n    Array.isArray(welcomeConfig?.suggestions) &&\n    welcomeConfig.suggestions.length > 0;\n\n  // Construct a mock message for the welcome (with description or just logo)\n  const welcomeMessage: AgentStartUIMessage = useMemo(\n    () => ({\n      id: \"welcome-message\",\n      role: \"assistant\",\n      parts: hasDescription\n        ? [{ type: \"text\", text: welcomeConfig?.description ?? \"\" }]\n        : [],\n    }),\n    [hasDescription, welcomeConfig?.description],\n  );\n\n  // Don't show if there are messages or welcome is not enabled\n  if (messages.length > 0 || !welcomeConfig?.enabled) {\n    return null;\n  }\n\n  // Need at least logo or description or suggestions\n  if (!hasLogo && !hasDescription && !hasSuggestions) {\n    return null;\n  }\n\n  return (\n    <AnimatePresence mode=\"wait\">\n      <div className={className}>\n        {(hasLogo || hasDescription) && (\n          <motion.div\n            key=\"welcome-message\"\n            initial={{ opacity: 0, y: 12 }}\n            animate={{ opacity: 1, y: 0 }}\n            exit={{ opacity: 0, y: 12 }}\n            transition={{ duration: 0.3, ease: \"easeOut\" }}\n          >\n            <ConversationMessage\n              message={welcomeMessage}\n              isLastMessage={false}\n              status=\"ready\"\n              regenerate={async () => {}}\n            />\n          </motion.div>\n        )}\n\n        {hasSuggestions && welcomeConfig.suggestions && (\n          <motion.div\n            key=\"welcome-suggestions\"\n            initial={{ opacity: 0, y: 12 }}\n            animate={{ opacity: 1, y: 0 }}\n            exit={{ opacity: 0, y: 12 }}\n            transition={{ duration: 0.3, ease: \"easeOut\", delay: 0.1 }}\n            className=\"mt-2 flex flex-col gap-2\"\n          >\n            <div className=\"w-fit px-0.5 text-muted-foreground text-sm\">\n              Try asking:\n            </div>\n            <div className=\"flex flex-wrap items-center gap-2\">\n              {welcomeConfig.suggestions.map(\n                (suggestion: string, index: number) => (\n                  <motion.div\n                    key={suggestion}\n                    initial={{ opacity: 0, y: 10 }}\n                    animate={{ opacity: 1, y: 0 }}\n                    exit={{ opacity: 0, scale: 0.95 }}\n                    transition={{\n                      duration: 0.2,\n                      delay: 0.1 + index * 0.05,\n                      ease: \"easeOut\",\n                    }}\n                  >\n                    <Button\n                      variant=\"outline\"\n                      size=\"sm\"\n                      onClick={() => handleSuggestionClick(suggestion)}\n                      disabled={isLoading}\n                    >\n                      {sendingSuggestion === suggestion && <Spinner />}\n                      {suggestion}\n                      <ArrowUpRightIcon className=\"size-3\" weight=\"bold\" />\n                    </Button>\n                  </motion.div>\n                ),\n              )}\n            </div>\n          </motion.div>\n        )}\n      </div>\n    </AnimatePresence>\n  );\n}\n",
      "type": "registry:component",
      "target": "components/agent/welcome-message.tsx"
    },
    {
      "path": "src/registry/agentstart/conversation/conversation-message.tsx",
      "content": "/* agent-frontmatter:start\nAGENT: Conversation message renderer\nPURPOSE: Render individual user and assistant messages with actions and content\nUSAGE: Import and use in conversation views to display message bubbles\nEXPORTS: ConversationMessage, ConversationMessageProps\nFEATURES:\n  - Renders user messages with image attachments and text\n  - Renders assistant messages with tool parts and streaming\n  - Includes message actions (copy, retry, timestamp)\n  - Handles source citations display\nSEARCHABLE: conversation message, message renderer, user message, assistant message\nagent-frontmatter:end */\n\n\"use client\";\n\nimport {\n  ArrowsClockwiseIcon,\n  CheckIcon,\n  CopyIcon,\n} from \"@phosphor-icons/react\";\nimport type { AgentStartUIMessage } from \"agentstart/agent\";\nimport { type AgentStore, useAgentStartContext } from \"agentstart/client\";\nimport { isToolUIPart } from \"ai\";\nimport { useCallback, useEffect, useRef, useState } from \"react\";\nimport { Avatar, AvatarFallback, AvatarImage } from \"@/components/ui/avatar\";\nimport { Button } from \"@/components/ui/button\";\nimport { cn } from \"@/lib/utils\";\nimport { Message, MessageContent } from \"../message\";\nimport { RelativeTime } from \"../relative-time\";\nimport { Response } from \"../response\";\nimport { Source, Sources, SourcesContent, SourcesTrigger } from \"../sources\";\nimport { MessagePart } from \"../tools/message-part-view\";\n\n// Helper types\ntype MessagePartType = NonNullable<AgentStartUIMessage[\"parts\"]>[number];\ntype TextPart = MessagePartType & { type: \"text\"; text: string };\ntype ImagePart = MessagePartType & {\n  type: \"file\";\n  url: string;\n  mediaType: string;\n  filename?: string;\n};\n\n// Type guards\nconst isTextPart = (part: MessagePartType): part is TextPart =>\n  part?.type === \"text\" &&\n  typeof part.text === \"string\" &&\n  part.text.length > 0;\n\nconst isImagePart = (part: MessagePartType): part is ImagePart =>\n  part?.type === \"file\" &&\n  typeof part.mediaType === \"string\" &&\n  (part.mediaType?.startsWith(\"image/\") ?? false) &&\n  typeof part.url === \"string\" &&\n  (part.url?.length ?? 0) > 0;\n\nconst copyMessageText = (message: AgentStartUIMessage): void => {\n  const parts = message.parts ?? [];\n  if (parts.length === 0) return;\n\n  const contentParts: string[] = [];\n  const sources: Array<{ url: string; title?: string }> = [];\n\n  for (const part of parts) {\n    // Text content\n    if (part.type === \"text\" && part.text) {\n      contentParts.push(part.text);\n    }\n    // Reasoning blocks\n    else if (part.type === \"reasoning\" && part.text) {\n      contentParts.push(`[Thinking]\\n${part.text}`);\n    }\n    // Tool executions\n    else if (isToolUIPart(part)) {\n      const toolName = part.type.replace(\"tool-\", \"\");\n      let toolSection = `[Tool: ${toolName}]`;\n\n      // Format tool input based on type\n      if (part.input) {\n        if (part.type === \"tool-bash\" && part.input.command) {\n          toolSection += `\\nCommand: ${part.input.command}`;\n        } else if (part.type === \"tool-read\" && part.input.filePath) {\n          toolSection += `\\nFile: ${part.input.filePath}`;\n        } else if (part.type === \"tool-write\" && part.input.filePath) {\n          toolSection += `\\nFile: ${part.input.filePath}`;\n        } else if (part.type === \"tool-edit\" && part.input.filePath) {\n          toolSection += `\\nFile: ${part.input.filePath}`;\n        } else if (part.type === \"tool-glob\" && part.input.pattern) {\n          toolSection += `\\nPattern: ${part.input.pattern}`;\n        } else if (part.type === \"tool-grep\" && part.input.pattern) {\n          toolSection += `\\nPattern: ${part.input.pattern}`;\n        } else if (part.type === \"tool-ls\" && part.input.path) {\n          toolSection += `\\nPath: ${part.input.path}`;\n        } else {\n          // Generic fallback for other tools\n          toolSection += `\\nInput: ${JSON.stringify(part.input)}`;\n        }\n      }\n\n      // Format tool output\n      if (part.output?.metadata) {\n        if (part.type === \"tool-bash\") {\n          if (part.output.metadata.stdout)\n            toolSection += `\\nOutput:\\n${part.output.metadata.stdout}`;\n          if (part.output.metadata.stderr)\n            toolSection += `\\nError:\\n${part.output.metadata.stderr}`;\n        } else if (part.type === \"tool-read\" && part.output.metadata.content) {\n          toolSection += `\\nContent:\\n${part.output.metadata.content}`;\n        } else if (\n          part.type === \"tool-grep\" &&\n          (part.output.metadata.files ||\n            part.output.metadata.matches ||\n            part.output.metadata.counts)\n        ) {\n          if (part.output.metadata.files) {\n            toolSection += `\\nFiles:\\n${part.output.metadata.files.join(\"\\n\")}`;\n          } else if (part.output.metadata.matches) {\n            toolSection += `\\nMatches:\\n${part.output.metadata.matches.join(\"\\n\")}`;\n          } else if (part.output.metadata.counts) {\n            toolSection += `\\nCounts:\\n${part.output.metadata.counts.map((c: any) => `${c.filename}: ${c.count}`).join(\"\\n\")}`;\n          }\n        } else if (part.type === \"tool-glob\" && part.output.metadata.matches) {\n          toolSection += `\\nMatches:\\n${part.output.metadata.matches.join(\"\\n\")}`;\n        } else if (part.output.prompt) {\n          toolSection += `\\nResult: ${part.output.prompt}`;\n        }\n      } else if (part.output?.prompt) {\n        toolSection += `\\nResult: ${part.output.prompt}`;\n      }\n\n      contentParts.push(toolSection);\n    }\n    // Source URLs\n    else if (part.type === \"source-url\") {\n      const sourcePart = part;\n      sources.push({\n        url: sourcePart.url,\n        title: sourcePart.title,\n      });\n    }\n  }\n\n  // Add sources at the end\n  if (sources.length > 0) {\n    const sourceLines = sources.map((s) => `- [${s.title || s.url}](${s.url})`);\n    contentParts.push(`\\nSources:\\n${sourceLines.join(\"\\n\")}`);\n  }\n\n  if (contentParts.length === 0) return;\n\n  const fullText = contentParts.join(\"\\n\\n\");\n  void navigator.clipboard.writeText(fullText);\n};\n\ntype CopyButtonProps = {\n  onCopy: () => void;\n  feedbackDuration?: number;\n  className?: string;\n  size?: \"icon-sm\" | \"sm\" | \"default\" | \"lg\" | \"icon\";\n  variant?:\n    | \"ghost\"\n    | \"default\"\n    | \"destructive\"\n    | \"outline\"\n    | \"secondary\"\n    | \"link\";\n};\n\nconst CopyButton = ({\n  onCopy,\n  feedbackDuration = 3000,\n  className,\n  size,\n  variant,\n}: CopyButtonProps) => {\n  const [isCopied, setIsCopied] = useState(false);\n  const timeoutRef = useRef<NodeJS.Timeout | null>(null);\n\n  useEffect(() => {\n    return () => {\n      if (timeoutRef.current) {\n        clearTimeout(timeoutRef.current);\n      }\n    };\n  }, []);\n\n  const handleClick = () => {\n    if (timeoutRef.current) {\n      clearTimeout(timeoutRef.current);\n    }\n\n    onCopy();\n    setIsCopied(true);\n\n    timeoutRef.current = setTimeout(() => {\n      setIsCopied(false);\n      timeoutRef.current = null;\n    }, feedbackDuration);\n  };\n\n  return (\n    <Button\n      onClick={handleClick}\n      disabled={isCopied}\n      className={className}\n      size={size}\n      variant={variant}\n    >\n      {isCopied ? (\n        <CheckIcon className=\"size-4\" weight=\"bold\" />\n      ) : (\n        <CopyIcon className=\"size-4\" weight=\"duotone\" />\n      )}\n      <span className=\"sr-only\">{isCopied ? \"Copied\" : \"Copy\"}</span>\n    </Button>\n  );\n};\n\nexport type ConversationMessageProps = {\n  message: AgentStartUIMessage;\n  isLastMessage: boolean;\n  status: AgentStore<AgentStartUIMessage>[\"status\"];\n  regenerate: AgentStore<AgentStartUIMessage>[\"regenerate\"];\n};\n\nexport function ConversationMessage({\n  message,\n  isLastMessage,\n  status,\n  regenerate,\n}: ConversationMessageProps) {\n  const { threadId, config } = useAgentStartContext();\n\n  const logo = config?.logo;\n  const logoSrc = typeof logo === \"string\" ? logo : logo?.src;\n  const logoAlt = typeof logo === \"string\" ? \"Logo\" : logo?.alt || \"Logo\";\n  const logoWidth = typeof logo === \"string\" ? undefined : logo?.width;\n  const logoHeight = typeof logo === \"string\" ? undefined : logo?.height;\n  const renderAssistantMessage = useCallback(\n    (message: AgentStartUIMessage, isLastMessage: boolean) => {\n      const parts = message.parts ?? [];\n      const elements: React.ReactElement[] = [];\n\n      // Render logo if configured\n      if (logoSrc) {\n        // Generate fallback initials from logoAlt\n        const fallbackText = logoAlt\n          .split(\" \")\n          .map((word) => word[0])\n          .join(\"\")\n          .slice(0, 2)\n          .toUpperCase();\n\n        if (parts.length > 0) {\n          // Logo with content: left-right layout\n          elements.push(\n            <div key=\"logo-header\" className=\"flex flex-col items-start gap-3\">\n              <div className=\"shrink-0\">\n                <Avatar style={{ width: logoWidth, height: logoHeight }}>\n                  <AvatarImage src={logoSrc} alt={logoAlt} />\n                  <AvatarFallback>{fallbackText}</AvatarFallback>\n                </Avatar>\n              </div>\n              <div className=\"flex-1 space-y-2\">\n                {parts.map((part, index) => (\n                  <MessagePart\n                    key={`${message.id}-tool-${index}`}\n                    part={part}\n                    isStreaming={\n                      isLastMessage &&\n                      status === \"streaming\" &&\n                      index === parts.length - 1\n                    }\n                  />\n                ))}\n              </div>\n            </div>,\n          );\n        } else {\n          // Logo only: standalone display\n          elements.push(\n            <div key=\"logo-only\" className=\"flex justify-start\">\n              <Avatar className=\"size-12\">\n                <AvatarImage\n                  src={logoSrc}\n                  alt={logoAlt}\n                  width={logoWidth}\n                  height={logoHeight}\n                />\n                <AvatarFallback>{fallbackText}</AvatarFallback>\n              </Avatar>\n            </div>,\n          );\n        }\n      } else {\n        // Regular rendering without logo\n        elements.push(\n          ...parts.map((part, index) => (\n            <MessagePart\n              key={`${message.id}-tool-${index}`}\n              part={part}\n              isStreaming={\n                isLastMessage &&\n                status === \"streaming\" &&\n                index === parts.length - 1\n              }\n            />\n          )),\n        );\n      }\n\n      return elements;\n    },\n    [status, logoSrc, logoAlt, logoWidth, logoHeight],\n  );\n\n  const renderUserMessage = useCallback((message: AgentStartUIMessage) => {\n    const parts = (message.parts ?? []) as MessagePartType[];\n    const textParts = parts.filter(isTextPart);\n    const imageParts = parts.filter(isImagePart);\n\n    if (textParts.length === 0 && imageParts.length === 0) {\n      return null;\n    }\n\n    return (\n      <div className=\"flex w-full flex-col gap-2\">\n        {imageParts.length > 0 ? (\n          <div\n            className={cn(\n              \"grid gap-2\",\n              imageParts.length === 1 ? \"grid-cols-1\" : \"grid-cols-2\",\n            )}\n          >\n            {imageParts.map((part, index) => (\n              <figure\n                key={`${message.id}-image-${index}`}\n                className=\"relative overflow-hidden rounded-md border bg-muted\"\n              >\n                <img\n                  alt={part.filename || `Attachment ${index + 1}`}\n                  className=\"h-full max-h-60 w-full object-cover\"\n                  loading=\"lazy\"\n                  src={part.url}\n                />\n                {part.filename ? (\n                  <figcaption className=\"sr-only\">{part.filename}</figcaption>\n                ) : null}\n              </figure>\n            ))}\n          </div>\n        ) : null}\n\n        {textParts.map((part, index) => (\n          <Response key={`${message.id}-text-${index}`}>{part.text}</Response>\n        ))}\n      </div>\n    );\n  }, []);\n\n  const renderUserActions = (message: AgentStartUIMessage) => (\n    <div className=\"flex items-center gap-1 opacity-0 group-hover:opacity-100\">\n      <CopyButton\n        className=\"size-7\"\n        size=\"icon-sm\"\n        variant=\"ghost\"\n        onCopy={() => copyMessageText(message)}\n      />\n\n      <RelativeTime timestamp={message.metadata?.createdAt} />\n    </div>\n  );\n\n  const renderAssistantActions = (message: AgentStartUIMessage) => {\n    const parts = message.parts ?? [];\n    const sourceParts = parts.filter((part) => part.type === \"source-url\");\n\n    return (\n      <>\n        <div className=\"flex w-full items-center justify-start gap-1 opacity-0 group-hover:opacity-100\">\n          <Button\n            className=\"size-7\"\n            size=\"icon-sm\"\n            variant=\"ghost\"\n            onClick={() =>\n              regenerate({\n                body: {\n                  threadId,\n                },\n              })\n            }\n          >\n            <ArrowsClockwiseIcon className=\"size-4\" weight=\"duotone\" />\n            <span className=\"sr-only\">Retry</span>\n          </Button>\n\n          <CopyButton\n            className=\"size-7\"\n            size=\"icon-sm\"\n            variant=\"ghost\"\n            onCopy={() => copyMessageText(message)}\n          />\n\n          <RelativeTime timestamp={message.metadata?.createdAt} />\n        </div>\n\n        {sourceParts.length > 0 && (\n          <div className=\"w-full\">\n            <Sources>\n              <SourcesTrigger count={sourceParts.length} />\n              <SourcesContent>\n                {sourceParts.map((part, index) => {\n                  return (\n                    <Source\n                      key={`${message.id}-source-${index}`}\n                      href={part.url}\n                      title={part.title || part.url}\n                    />\n                  );\n                })}\n              </SourcesContent>\n            </Sources>\n          </div>\n        )}\n      </>\n    );\n  };\n\n  if (message.role === \"system\") {\n    return null;\n  }\n\n  return (\n    <Message\n      from={message.role}\n      key={message.id}\n      className={cn(\"flex-col\", {\n        \"items-start\": message.role === \"assistant\",\n        \"items-end\": message.role === \"user\",\n      })}\n    >\n      {message.role === \"user\" && renderUserActions(message)}\n\n      <MessageContent\n        className={cn({\n          \"space-y-2\": message.role === \"assistant\",\n          \"mb-2\": message.role === \"user\",\n          \"text-base ltr:rounded-br-none! rtl:rounded-bl-none!\":\n            message.role === \"user\",\n        })}\n        variant={message.role === \"assistant\" ? \"flat\" : \"contained\"}\n      >\n        {message.role === \"assistant\"\n          ? renderAssistantMessage(message, isLastMessage)\n          : renderUserMessage(message)}\n      </MessageContent>\n\n      {message.role === \"assistant\" && [\"ready\", \"error\"].includes(status)\n        ? renderAssistantActions(message)\n        : null}\n    </Message>\n  );\n}\n",
      "type": "registry:component",
      "target": "components/agent/conversation/conversation-message.tsx"
    },
    {
      "path": "src/registry/agentstart/message.tsx",
      "content": "/* agent-frontmatter:start\nAGENT: Conversation message shells\nPURPOSE: Provide styled wrappers for user and assistant messages in transcripts\nUSAGE: import { Message, MessageContent, MessageAvatar } from \\\"@/components/agent/message\\\"\nEXPORTS: Message, MessageContent, MessageAvatar\nFEATURES:\n  - Variant-aware message body styling\n  - Avatar helper for sender identity\nSEARCHABLE: message layout, avatar, transcript message, agent bubble\nagent-frontmatter:end */\n\nimport type { UIMessage } from \"ai\";\nimport { cva, type VariantProps } from \"class-variance-authority\";\nimport type { ComponentProps, HTMLAttributes } from \"react\";\nimport { Avatar, AvatarFallback, AvatarImage } from \"@/components/ui/avatar\";\nimport { cn } from \"@/lib/utils\";\n\nexport type MessageProps = HTMLAttributes<HTMLDivElement> & {\n  from: UIMessage[\"role\"];\n};\n\nexport const Message = ({ className, from, ...props }: MessageProps) => (\n  <div\n    className={cn(\n      \"group flex w-full items-end justify-end gap-2\",\n      from === \"user\" ? \"is-user\" : \"is-assistant flex-row-reverse justify-end\",\n      className,\n    )}\n    {...props}\n  />\n);\n\nconst messageContentVariants = cva(\n  \"group-[.is-user]:dark flex max-w-full flex-col gap-2 overflow-hidden text-sm group-[.is-user]:rounded-xl\",\n  {\n    variants: {\n      variant: {\n        contained: [\n          \"max-w-[80%] px-4 py-3\",\n          \"group-[.is-user]:bg-secondary group-[.is-user]:text-secondary-foreground\",\n        ],\n        flat: [\n          \"group-[.is-user]:max-w-[80%] group-[.is-user]:bg-secondary group-[.is-user]:px-4 group-[.is-user]:py-3 group-[.is-user]:text-foreground\",\n        ],\n      },\n    },\n    defaultVariants: {\n      variant: \"contained\",\n    },\n  },\n);\n\nexport type MessageContentProps = HTMLAttributes<HTMLDivElement> &\n  VariantProps<typeof messageContentVariants>;\n\nexport const MessageContent = ({\n  children,\n  className,\n  variant,\n  ...props\n}: MessageContentProps) => (\n  <div\n    className={cn(messageContentVariants({ variant, className }))}\n    {...props}\n  >\n    {children}\n  </div>\n);\n\nexport type MessageAvatarProps = ComponentProps<typeof Avatar> & {\n  src: string;\n  name?: string;\n};\n\nexport const MessageAvatar = ({\n  src,\n  name,\n  className,\n  ...props\n}: MessageAvatarProps) => (\n  <Avatar className={cn(\"size-8 ring-1 ring-border\", className)} {...props}>\n    <AvatarImage alt=\"\" className=\"mt-0 mb-0\" src={src} />\n    <AvatarFallback>{name?.slice(0, 2) || \"ME\"}</AvatarFallback>\n  </Avatar>\n);\n",
      "type": "registry:component",
      "target": "components/agent/message.tsx"
    },
    {
      "path": "src/registry/agentstart/relative-time.tsx",
      "content": "/* agent-frontmatter:start\nAGENT: Relative time display component\nPURPOSE: Display human-readable relative timestamps with detailed tooltip\nUSAGE: <RelativeTime timestamp={timestamp} />\nEXPORTS: RelativeTime, RelativeTimeProps\nFEATURES:\n  - Displays simple relative time in trigger (e.g., \"2 days ago\")\n  - Shows detailed relative time in tooltip (e.g., \"2 days, 12 hours ago\")\n  - Shows UTC and local timezone in tooltip on hover\n  - Auto-updates every minute\n  - Handles Date objects and Unix timestamps\nSEARCHABLE: relative time, timestamp, time display, date formatting, timezone\nagent-frontmatter:end */\n\n\"use client\";\n\nimport { format, intervalToDuration } from \"date-fns\";\nimport type { ComponentProps, ReactNode } from \"react\";\nimport { useEffect, useMemo, useState } from \"react\";\nimport { Badge } from \"@/components/ui/badge\";\nimport { Tooltip, TooltipPopup, TooltipTrigger } from \"@/components/ui/tooltip\";\n\nexport type RelativeTimeProps = {\n  /**\n   * Custom element to render before the time\n   */\n  leading?: ReactNode;\n  timestamp?: number | Date;\n} & Omit<ComponentProps<typeof TooltipTrigger>, \"children\">;\n\n/**\n * Calculate simple relative time (only the most significant unit)\n */\nfunction formatSimpleRelativeTime(date: Date): string {\n  const now = new Date();\n  const duration = intervalToDuration({ start: date, end: now });\n\n  // Return only the most significant time unit\n  if (duration.years && duration.years > 0) {\n    return `${duration.years} year${duration.years > 1 ? \"s\" : \"\"} ago`;\n  }\n  if (duration.months && duration.months > 0) {\n    return `${duration.months} month${duration.months > 1 ? \"s\" : \"\"} ago`;\n  }\n  if (duration.days && duration.days > 0) {\n    return `${duration.days} day${duration.days > 1 ? \"s\" : \"\"} ago`;\n  }\n  if (duration.hours && duration.hours > 0) {\n    return `${duration.hours} hour${duration.hours > 1 ? \"s\" : \"\"} ago`;\n  }\n  if (duration.minutes && duration.minutes > 0) {\n    return `${duration.minutes} minute${duration.minutes > 1 ? \"s\" : \"\"} ago`;\n  }\n  if (duration.seconds && duration.seconds > 0) {\n    return `${duration.seconds} second${duration.seconds > 1 ? \"s\" : \"\"} ago`;\n  }\n\n  return \"just now\";\n}\n\n/**\n * Calculate detailed relative time using date-fns intervalToDuration\n */\nfunction formatDetailedRelativeTime(date: Date): string {\n  const now = new Date();\n  const duration = intervalToDuration({ start: date, end: now });\n\n  const parts: string[] = [];\n\n  // Add up to 3 most significant time units\n  if (duration.years && duration.years > 0) {\n    parts.push(`${duration.years} year${duration.years > 1 ? \"s\" : \"\"}`);\n  }\n  if (duration.months && duration.months > 0 && parts.length < 3) {\n    parts.push(`${duration.months} month${duration.months > 1 ? \"s\" : \"\"}`);\n  }\n  if (duration.days && duration.days > 0 && parts.length < 3) {\n    parts.push(`${duration.days} day${duration.days > 1 ? \"s\" : \"\"}`);\n  }\n  if (duration.hours && duration.hours > 0 && parts.length < 3) {\n    parts.push(`${duration.hours} hour${duration.hours > 1 ? \"s\" : \"\"}`);\n  }\n  if (duration.minutes && duration.minutes > 0 && parts.length < 3) {\n    parts.push(`${duration.minutes} minute${duration.minutes > 1 ? \"s\" : \"\"}`);\n  }\n  if (duration.seconds && duration.seconds > 0 && parts.length < 3) {\n    parts.push(`${duration.seconds} second${duration.seconds > 1 ? \"s\" : \"\"}`);\n  }\n\n  return parts.length > 0 ? `${parts.join(\", \")} ago` : \"just now\";\n}\n\n/**\n * Get timezone offset string (e.g., \"GMT+8\", \"UTC\")\n */\nfunction getTimezoneString(): string {\n  const offset = -new Date().getTimezoneOffset();\n  if (offset === 0) return \"UTC\";\n\n  const hours = Math.floor(Math.abs(offset) / 60);\n  const minutes = Math.abs(offset) % 60;\n  const sign = offset >= 0 ? \"+\" : \"-\";\n\n  return `GMT${sign}${hours}${minutes > 0 ? `:${minutes.toString().padStart(2, \"0\")}` : \"\"}`;\n}\n\nexport const RelativeTime = ({\n  leading,\n  timestamp,\n  className,\n  ...props\n}: RelativeTimeProps) => {\n  const [simpleRelativeTime, setSimpleRelativeTime] = useState<string>(\"\");\n  const [detailedRelativeTime, setDetailedRelativeTime] = useState<string>(\"\");\n\n  // Format detailed time info for tooltip\n  const timeInfo = useMemo(() => {\n    if (!timestamp) return null;\n\n    const date = new Date(timestamp);\n    const utcDate = format(date, \"MMMM d, yyyy\");\n    const utcTime = format(date, \"hh:mm:ss a\");\n    const localDate = format(date, \"MMMM d, yyyy\");\n    const localTime = format(date, \"hh:mm:ss a\");\n    const timezone = getTimezoneString();\n\n    return {\n      utcDate,\n      utcTime,\n      localDate,\n      localTime,\n      timezone,\n    };\n  }, [timestamp]);\n\n  // Update relative times periodically\n  useEffect(() => {\n    if (!timestamp) {\n      setSimpleRelativeTime(\"\");\n      setDetailedRelativeTime(\"\");\n      return;\n    }\n\n    const updateRelativeTimes = () => {\n      const date = new Date(timestamp);\n      setSimpleRelativeTime(formatSimpleRelativeTime(date));\n      setDetailedRelativeTime(formatDetailedRelativeTime(date));\n    };\n\n    updateRelativeTimes();\n    const interval = setInterval(updateRelativeTimes, 60000); // Update every minute\n\n    return () => clearInterval(interval);\n  }, [timestamp]);\n\n  if (!timestamp || !simpleRelativeTime || !timeInfo) {\n    return null;\n  }\n\n  return (\n    <Tooltip>\n      <TooltipTrigger\n        className={className ?? \"cursor-default text-muted-foreground text-xs\"}\n        {...props}\n      >\n        {leading} {simpleRelativeTime}\n      </TooltipTrigger>\n      <TooltipPopup>\n        <div className=\"space-y-2 text-xs\">\n          {/* Detailed relative time at the top */}\n          <div className=\"text-left\">{detailedRelativeTime}</div>\n\n          {/* UTC and local timezone */}\n          <div className=\"space-y-1\">\n            <div className=\"flex items-center justify-between gap-4\">\n              <div className=\"flex items-center gap-1\">\n                <Badge variant=\"secondary\">UTC</Badge>\n                <div>{timeInfo.utcDate}</div>\n              </div>\n              <div className=\"text-right\">\n                <div className=\"text-muted-foreground\">{timeInfo.utcTime}</div>\n              </div>\n            </div>\n            <div className=\"flex items-center justify-between gap-4\">\n              <div className=\"flex items-center gap-1\">\n                <Badge variant=\"secondary\">{timeInfo.timezone}</Badge>\n                <div>{timeInfo.localDate}</div>\n              </div>\n              <div className=\"text-right\">\n                <div className=\"text-muted-foreground\">\n                  {timeInfo.localTime}\n                </div>\n              </div>\n            </div>\n          </div>\n        </div>\n      </TooltipPopup>\n    </Tooltip>\n  );\n};\n",
      "type": "registry:component",
      "target": "components/agent/relative-time.tsx"
    },
    {
      "path": "src/registry/agentstart/response.tsx",
      "content": "/* agent-frontmatter:start\nAGENT: Markdown response renderer\nPURPOSE: Render assistant text parts using Streamdown with stable memoization\nUSAGE: import { Response } from \\\"@/components/agent/response\\\"\nEXPORTS: Response\nFEATURES:\n  - Applies consistent typography to markdown streams\n  - Memoizes children to avoid unnecessary rerenders\nSEARCHABLE: markdown renderer, streamdown response, agent output\nagent-frontmatter:end */\n\n\"use client\";\n\nimport {\n  MagnifyingGlassMinusIcon,\n  MagnifyingGlassPlusIcon,\n} from \"@phosphor-icons/react\";\nimport { type ComponentProps, memo } from \"react\";\nimport Zoom from \"react-medium-image-zoom\";\nimport type { BundledLanguage } from \"shiki/bundle/web\";\nimport { Streamdown } from \"streamdown\";\nimport { cn } from \"@/lib/utils\";\nimport { CodeBlock } from \"./code-block\";\nimport \"react-medium-image-zoom/dist/styles.css\";\n\ntype ResponseProps = ComponentProps<typeof Streamdown>;\n\nexport const Response = memo(\n  ({ className, ...props }: ResponseProps) => (\n    <Streamdown\n      className={cn(\n        \"size-full text-base [&>*:first-child]:mt-0 [&>*:last-child]:mb-0\",\n        className,\n      )}\n      components={{\n        pre: ({ children, node, ...props }) => {\n          const [firstChild] = node?.children ?? [];\n\n          if (\n            firstChild &&\n            firstChild.type === \"element\" &&\n            firstChild.tagName === \"code\" &&\n            firstChild.children[0]?.type === \"text\"\n          ) {\n            const { className } = firstChild.properties;\n            const [, language = \"plaintext\"] =\n              /language-(.+)/.exec(String(className) || \"\") ?? [];\n            const code = firstChild.children[0].value.trim();\n\n            return (\n              <pre {...props}>\n                <CodeBlock\n                  className=\"my-4\"\n                  code={code}\n                  language={language as BundledLanguage}\n                />\n              </pre>\n            );\n          }\n\n          const lang = props.className?.split(\"language-\")[1] ?? \"markdown\";\n          return (\n            <pre {...props}>\n              <CodeBlock\n                className=\"my-4\"\n                code={children as string}\n                language={lang as BundledLanguage}\n              />\n            </pre>\n          );\n        },\n        img: (props) => {\n          const { src, alt, ...rest } = props;\n          if (!src) return null;\n          return (\n            <Zoom\n              IconZoom={() => (\n                <MagnifyingGlassPlusIcon\n                  weight=\"duotone\"\n                  className=\"size-5.5\"\n                />\n              )}\n              IconUnzoom={() => (\n                <MagnifyingGlassMinusIcon\n                  weight=\"duotone\"\n                  className=\"size-5.5\"\n                />\n              )}\n            >\n              <img\n                className=\"my-2 block max-h-40 rounded-lg\"\n                src={src}\n                loading=\"lazy\"\n                alt={alt}\n                {...rest}\n              />\n            </Zoom>\n          );\n        },\n      }}\n      {...props}\n    />\n  ),\n  (prevProps, nextProps) => prevProps.children === nextProps.children,\n);\n\nResponse.displayName = \"Response\";\n",
      "type": "registry:component",
      "target": "components/agent/response.tsx"
    },
    {
      "path": "src/registry/agentstart/code-block.tsx",
      "content": "/* agent-frontmatter:start\nAGENT: Code block component with syntax highlighting\nPURPOSE: Render syntax-highlighted code snippets with line numbers and copy functionality\nUSAGE: <CodeBlock code={code} language=\"typescript\" showLineNumbers copyCode={originalCode} />\nEXPORTS: CodeBlock, CodeBlockCopyButton, highlightCode\nFEATURES:\n  - Dual-theme syntax highlighting (light/dark) using Shiki\n  - Optional line number display\n  - Copy-to-clipboard button with success feedback\n  - Separate copyCode prop to copy original content without diff markers\n  - Supports all Shiki bundled languages and diff notation\nSEARCHABLE: code block, syntax highlighting, shiki, copy button, diff\nagent-frontmatter:end */\n\n\"use client\";\n\nimport { CheckIcon, CopyIcon } from \"@phosphor-icons/react\";\nimport { transformerNotationDiff } from \"@shikijs/transformers\";\nimport { useTheme } from \"agentstart/client\";\nimport {\n  type ComponentProps,\n  createContext,\n  type HTMLAttributes,\n  useContext,\n  useEffect,\n  useRef,\n  useState,\n} from \"react\";\nimport {\n  type BundledLanguage,\n  codeToHtml,\n  type ShikiTransformer,\n} from \"shiki/bundle/web\";\nimport { Button } from \"@/components/ui/button\";\nimport { ScrollArea } from \"@/components/ui/scroll-area\";\nimport { cn } from \"@/lib/utils\";\n\ntype CodeBlockProps = HTMLAttributes<HTMLDivElement> & {\n  code: string;\n  language: BundledLanguage;\n  showLineNumbers?: boolean;\n  showCopyButton?: boolean;\n  showDiff?: boolean;\n  /** Original code without diff markers for copying */\n  copyCode?: string;\n};\n\ntype CodeBlockContextType = {\n  code: string;\n  copyCode: string;\n};\n\nconst CodeBlockContext = createContext<CodeBlockContextType>({\n  code: \"\",\n  copyCode: \"\",\n});\n\nconst lineNumberTransformer: ShikiTransformer = {\n  name: \"line-numbers\",\n  line(node, line) {\n    node.children.unshift({\n      type: \"element\",\n      tagName: \"span\",\n      properties: {\n        className: [\n          \"inline-block\",\n          \"min-w-10\",\n          \"mr-4\",\n          \"text-right\",\n          \"select-none\",\n          \"text-muted-foreground\",\n        ],\n      },\n      children: [{ type: \"text\", value: String(line) }],\n    });\n  },\n};\n\nexport async function highlightCode({\n  code,\n  language,\n  showLineNumbers = false,\n  showDiff = false,\n}: {\n  code: string;\n  language: BundledLanguage;\n  showLineNumbers: boolean;\n  showDiff: boolean;\n}) {\n  const transformers: ShikiTransformer[] = [];\n\n  if (showLineNumbers) {\n    transformers.push(lineNumberTransformer);\n  }\n\n  if (showDiff) {\n    transformers.push(transformerNotationDiff());\n  }\n\n  return await Promise.all([\n    codeToHtml(code, {\n      lang: language,\n      theme: \"vitesse-light\",\n      transformers,\n    }),\n    codeToHtml(code, {\n      lang: language,\n      theme: \"vesper\",\n      transformers,\n    }),\n  ]);\n}\n\nexport const CodeBlock = ({\n  code,\n  language,\n  showLineNumbers = false,\n  showCopyButton = true,\n  showDiff = false,\n  copyCode,\n  className,\n  children,\n  ...props\n}: CodeBlockProps) => {\n  const [html, setHtml] = useState<string>(\"\");\n  const [darkHtml, setDarkHtml] = useState<string>(\"\");\n  const mounted = useRef(false);\n  const { resolvedTheme } = useTheme();\n\n  useEffect(() => {\n    highlightCode({ code, language, showLineNumbers, showDiff }).then(\n      ([light, dark]) => {\n        if (!mounted.current) {\n          setHtml(light);\n          setDarkHtml(dark);\n          mounted.current = true;\n        }\n      },\n    );\n\n    return () => {\n      mounted.current = false;\n    };\n  }, [code, language, showLineNumbers, showDiff]);\n\n  return (\n    <CodeBlockContext.Provider value={{ code, copyCode: copyCode ?? code }}>\n      <div\n        className={cn(\n          \"group/code-block relative max-h-[200px] overflow-hidden rounded-lg border text-foreground\",\n          \"[&_.diff.add]:bg-green-500/10 [&_.diff.add]:text-green-600 [&_.diff.add]:before:absolute [&_.diff.add]:before:left-1 [&_.diff.add]:before:content-['+']\",\n          \"[&_.diff.remove]:bg-red-500/10 [&_.diff.remove]:text-red-600 [&_.diff.remove]:opacity-70 [&_.diff.remove]:before:absolute [&_.diff.remove]:before:left-1 [&_.diff.remove]:before:content-['-']\",\n          \"dark:[&_.diff.add]:bg-green-500/20 dark:[&_.diff.add]:text-green-400\",\n          \"dark:[&_.diff.remove]:bg-red-500/20 dark:[&_.diff.remove]:text-red-400\",\n          className,\n        )}\n        {...props}\n      >\n        <ScrollArea className=\"max-h-[200px]\">\n          <div\n            className={cn(\n              \"[&>pre]:m-0 [&>pre]:bg-background! [&>pre]:text-foreground! [&>pre]:text-sm\",\n              \"[&_code]:wrap-break-word [&_code]:block [&_code]:w-full [&_code]:border-none [&_code]:font-mono [&_code]:text-sm [&_code]:leading-normal\",\n              \"[&_.line]:relative [&_.line]:inline-block [&_.line]:w-full [&_.line]:px-4\",\n            )}\n            dangerouslySetInnerHTML={{\n              __html: resolvedTheme === \"dark\" ? darkHtml : html,\n            }}\n          />\n          {children && (\n            <div className=\"absolute top-2 right-2 flex items-center gap-2\">\n              {children}\n            </div>\n          )}\n        </ScrollArea>\n        {showCopyButton && (\n          <CodeBlockCopyButton className=\"absolute top-2 right-2 opacity-0 transition-opacity group-hover/code-block:opacity-100\" />\n        )}\n      </div>\n    </CodeBlockContext.Provider>\n  );\n};\n\nexport type CodeBlockCopyButtonProps = ComponentProps<typeof Button> & {\n  onCopy?: () => void;\n  onError?: (error: Error) => void;\n  timeout?: number;\n};\n\nexport const CodeBlockCopyButton = ({\n  onCopy,\n  onError,\n  timeout = 2000,\n  children,\n  className,\n  ...props\n}: CodeBlockCopyButtonProps) => {\n  const [isCopied, setIsCopied] = useState(false);\n  const { copyCode } = useContext(CodeBlockContext);\n\n  const copyToClipboard = async () => {\n    if (typeof window === \"undefined\" || !navigator?.clipboard?.writeText) {\n      onError?.(new Error(\"Clipboard API not available\"));\n      return;\n    }\n\n    try {\n      await navigator.clipboard.writeText(copyCode);\n      setIsCopied(true);\n      onCopy?.();\n      setTimeout(() => setIsCopied(false), timeout);\n    } catch (error) {\n      onError?.(error as Error);\n    }\n  };\n\n  const Icon = isCopied ? (\n    <CheckIcon weight=\"bold\" />\n  ) : (\n    <CopyIcon weight=\"duotone\" />\n  );\n\n  return (\n    <Button\n      className={cn(\"shrink-0\", className)}\n      onClick={copyToClipboard}\n      size=\"icon\"\n      variant=\"ghost\"\n      {...props}\n    >\n      {children ?? Icon}\n    </Button>\n  );\n};\n",
      "type": "registry:component",
      "target": "components/agent/code-block.tsx"
    },
    {
      "path": "src/registry/agentstart/sources.tsx",
      "content": "/* agent-frontmatter:start\nAGENT: Source citation accordion\nPURPOSE: Display expandable citation lists for assistant responses\nUSAGE: import { Sources, SourcesTrigger, SourcesContent, Source } from \\\"@/components/agent/sources\\\"\nEXPORTS: Sources, SourcesTrigger, SourcesContent, Source\nFEATURES:\n  - Collapsible list of used sources\n  - Provides default trigger and link styling\nSEARCHABLE: citations, sources list, collapsible references, agent sources\nagent-frontmatter:end */\n\n\"use client\";\n\nimport { BookIcon, CaretDownIcon } from \"@phosphor-icons/react\";\nimport type { ComponentProps } from \"react\";\nimport {\n  Collapsible,\n  CollapsibleContent,\n  CollapsibleTrigger,\n} from \"@/components/ui/collapsible\";\nimport { cn } from \"@/lib/utils\";\n\nexport type SourcesProps = ComponentProps<\"div\">;\n\nexport const Sources = ({ className, ...props }: SourcesProps) => (\n  <Collapsible\n    className={cn(\"not-prose mb-4 text-primary text-xs\", className)}\n    {...props}\n  />\n);\n\nexport type SourcesTriggerProps = ComponentProps<typeof CollapsibleTrigger> & {\n  count: number;\n};\n\nexport const SourcesTrigger = ({\n  className,\n  count,\n  children,\n  ...props\n}: SourcesTriggerProps) => (\n  <CollapsibleTrigger\n    className={cn(\"flex items-center gap-2\", className)}\n    {...props}\n  >\n    {children ?? (\n      <>\n        <p className=\"font-medium\">Used {count} sources</p>\n        <CaretDownIcon className=\"size-4\" />\n      </>\n    )}\n  </CollapsibleTrigger>\n);\n\nexport type SourcesContentProps = ComponentProps<typeof CollapsibleContent>;\n\nexport const SourcesContent = ({\n  className,\n  ...props\n}: SourcesContentProps) => (\n  <CollapsibleContent\n    className={cn(\n      \"mt-3 flex w-fit flex-col gap-2\",\n      \"data-[state=closed]:fade-out-0 data-[state=closed]:slide-out-to-top-2 data-[state=open]:slide-in-from-top-2 outline-none data-[state=closed]:animate-out data-[state=open]:animate-in\",\n      className,\n    )}\n    {...props}\n  />\n);\n\nexport type SourceProps = ComponentProps<\"a\">;\n\nexport const Source = ({ href, title, children, ...props }: SourceProps) => (\n  <a\n    className=\"flex items-center gap-2\"\n    href={href}\n    rel=\"noreferrer\"\n    target=\"_blank\"\n    {...props}\n  >\n    {children ?? (\n      <>\n        <BookIcon className=\"size-4\" weight=\"duotone\" />\n        <span className=\"block font-medium\">{title}</span>\n      </>\n    )}\n  </a>\n);\n",
      "type": "registry:component",
      "target": "components/agent/sources.tsx"
    },
    {
      "path": "src/registry/agentstart/tools/message-part-view.tsx",
      "content": "/* agent-frontmatter:start\nAGENT: Message part view orchestrator\nPURPOSE: Route different tool and content types to their specific UI components\nUSAGE: <MessagePart part={part} isStreaming={isStreaming} />\nEXPORTS: MessagePart\nFEATURES:\n  - Dispatches tool parts to specialized renderers (bash, read, write, etc.)\n  - Renders text content with markdown support\n  - Handles reasoning blocks with collapsible UI\n  - Supports all AgentStart tool visualizations\nSEARCHABLE: message view, tool renderer, part dispatcher, ui orchestrator\nagent-frontmatter:end */\n\nimport type { AgentStartToolSet, BaseMessagePart } from \"agentstart/agent\";\nimport { memo } from \"react\";\nimport isEqual from \"react-fast-compare\";\nimport { Response } from \"../response\";\nimport { Bash } from \"./bash\";\nimport { EditFile } from \"./edit\";\nimport { Glob } from \"./glob\";\nimport { Grep } from \"./grep\";\nimport { Ls } from \"./ls\";\nimport { ReadFile } from \"./read\";\nimport {\n  Reasoning as BaseReasoning,\n  getThinkingMessage,\n  ReasoningContent,\n  ReasoningTrigger,\n} from \"./reasoning\";\nimport { Todo } from \"./todo\";\nimport { WriteFile } from \"./write\";\n\n// ========= Add your custom tool types here =========\n// To add new tools, simply add them to the type below\n// Example:\n// type ExtendedToolSet = AgentStartToolSet & {\n//   myCustomTool?: any;  // Add other custom tools\n// }\ntype ExtendedToolSet = AgentStartToolSet;\n// ================================================\n\ninterface Props {\n  part: BaseMessagePart<ExtendedToolSet>;\n  isStreaming: boolean;\n}\n\nexport const MessagePart = memo<Props>(({ part, isStreaming }) => {\n  switch (part.type) {\n    case \"tool-read\": {\n      return <ReadFile part={part} />;\n    }\n    case \"tool-write\":\n      return <WriteFile part={part} />;\n    case \"tool-edit\":\n      return <EditFile part={part} />;\n    case \"tool-bash\":\n      return <Bash part={part} />;\n    case \"tool-glob\":\n      return <Glob part={part} />;\n    case \"tool-grep\":\n      return <Grep part={part} />;\n    case \"tool-ls\":\n      return <Ls part={part} />;\n    case \"tool-todoRead\":\n    case \"tool-todoWrite\":\n      return <Todo part={part} />;\n\n    case \"reasoning\":\n      return (\n        <Reasoning\n          className=\"w-full\"\n          isStreaming={isStreaming}\n          text={part.text}\n        />\n      );\n    case \"text\":\n      return <Response>{part.text}</Response>;\n    default:\n      return null;\n  }\n}, isEqual);\n\nfunction Reasoning({\n  className,\n  text,\n  isStreaming,\n}: {\n  className?: string;\n  text: string;\n  isStreaming: boolean;\n}) {\n  return (\n    <BaseReasoning\n      className={className}\n      isStreaming={isStreaming}\n      defaultOpen={false}\n    >\n      <ReasoningTrigger>{getThinkingMessage(isStreaming)}</ReasoningTrigger>\n      <ReasoningContent>{text}</ReasoningContent>\n    </BaseReasoning>\n  );\n}\n",
      "type": "registry:component",
      "target": "components/agent/tools/message-part-view.tsx"
    },
    {
      "path": "src/registry/agentstart/tools/bash.tsx",
      "content": "/* agent-frontmatter:start\nAGENT: Bash tool UI component\nPURPOSE: Display shell command execution results with stdout/stderr output\nUSAGE: <Bash part={toolPart} />\nEXPORTS: Bash, BashProps\nFEATURES:\n  - Shows executed command with description\n  - Renders stdout and stderr with syntax highlighting\n  - Displays execution duration and exit code\n  - Distinguishes between success and error states\nSEARCHABLE: bash tool, shell command ui, terminal output view\nagent-frontmatter:end */\n\nimport { CommandIcon } from \"@phosphor-icons/react\";\nimport type { Tools } from \"agentstart/agent\";\nimport type { InferUITools, ToolUIPart } from \"ai\";\nimport { useMemo } from \"react\";\nimport {\n  Tooltip,\n  TooltipContent,\n  TooltipTrigger,\n} from \"@/components/ui/tooltip\";\nimport { CodeBlock } from \"../code-block\";\nimport { Steps, StepsContent, StepsItem, StepsTrigger } from \"../steps\";\n\nexport interface BashProps {\n  part: ToolUIPart<InferUITools<Pick<Tools, \"bash\">>>;\n}\n\nexport function Bash({ part: { state, input, output } }: BashProps) {\n  const hasOutput = output?.metadata?.stdout || output?.metadata?.stderr;\n  const formatDuration = (ms?: number) => {\n    if (!ms) return \"\";\n    return ms < 1000 ? `${ms}ms` : `${(ms / 1000).toFixed(2)}s`;\n  };\n  const isLoading = [\"input-streaming\", \"input-available\"].includes(state);\n\n  const title = useMemo(() => {\n    if (!input?.command) return <span>Ran command</span>;\n    return (\n      <div className=\"flex w-full items-center gap-2 overflow-hidden\">\n        Ran command:\n        <Tooltip>\n          <TooltipTrigger\n            render={\n              <span className=\"flex-1 truncate text-left font-mono text-foreground\">\n                {input?.command}\n              </span>\n            }\n          />\n          <TooltipContent align=\"start\">\n            <div className=\"flex flex-col gap-1\">\n              {input?.description && (\n                <span className=\"text-muted-foreground text-xs\">\n                  {input.description}\n                </span>\n              )}\n\n              {/* Exit code and duration */}\n              {state === \"output-available\" && output && (\n                <div className=\"flex items-center gap-4 text-muted-foreground text-xs\">\n                  {output.metadata?.exitCode !== undefined && (\n                    <span\n                      className={\n                        output.metadata.exitCode === 0\n                          ? undefined\n                          : \"text-yellow-600\"\n                      }\n                    >\n                      Exit code: {output.metadata.exitCode}\n                    </span>\n                  )}\n                  {output.metadata?.duration && (\n                    <span>\n                      Duration: {formatDuration(output.metadata.duration)}\n                    </span>\n                  )}\n                  {/* {output.metadata?.commitHash && (\n            <CommitHash hash={output.metadata.commitHash} />\n          )} */}\n                </div>\n              )}\n            </div>\n          </TooltipContent>\n        </Tooltip>\n      </div>\n    );\n  }, [input?.command, input?.description, output, state]);\n\n  return (\n    <Steps data-tool-bash>\n      <StepsTrigger\n        loading={isLoading}\n        error={output?.status === \"error\" || Boolean(output?.error)}\n        leftIcon={<CommandIcon weight=\"duotone\" className=\"size-4\" />}\n      >\n        {title}\n      </StepsTrigger>\n      <StepsContent>\n        <StepsItem>\n          <div className=\"space-x-2\">\n            <span className=\"text-sm\">$</span>\n            <span className=\"font-mono text-foreground text-sm\">\n              {input?.command}\n            </span>\n          </div>\n        </StepsItem>\n\n        {/* Status indicators */}\n        {isLoading && (\n          <StepsItem className=\"flex items-center gap-2 text-muted-foreground text-xs\">\n            <span>Executing command...</span>\n          </StepsItem>\n        )}\n\n        {/* Standard output */}\n        {output?.metadata?.stdout && (\n          <StepsItem>\n            <CodeBlock code={output.metadata.stdout} language=\"bash\" />\n          </StepsItem>\n        )}\n\n        {/* No output message */}\n        {state === \"output-available\" && output && !hasOutput && (\n          <StepsItem>Command executed successfully (no output)</StepsItem>\n        )}\n\n        {/* Standard error */}\n        {output?.metadata?.stderr && (\n          <StepsItem>\n            <CodeBlock\n              code={output.metadata.stderr}\n              language=\"bash\"\n              className=\"border-red-200 text-xs dark:border-red-900\"\n            />\n          </StepsItem>\n        )}\n      </StepsContent>\n    </Steps>\n  );\n}\n",
      "type": "registry:component",
      "target": "components/agent/tools/bash.tsx"
    },
    {
      "path": "src/registry/agentstart/tools/glob.tsx",
      "content": "/* agent-frontmatter:start\nAGENT: Glob tool UI component\nPURPOSE: Display file pattern matching results from glob tool\nUSAGE: <Glob part={toolPart} />\nEXPORTS: Glob, GlobProps\nFEATURES:\n  - Renders matched file and directory paths\n  - Color-coded icons for files vs directories\n  - Shows pattern used and match count\n  - Highlights filename vs directory path distinction\nSEARCHABLE: glob tool, file pattern match ui, file search results\nagent-frontmatter:end */\n\nimport {\n  FileIcon,\n  FileMagnifyingGlassIcon,\n  FolderIcon,\n} from \"@phosphor-icons/react\";\nimport type { Tools } from \"agentstart/agent\";\nimport type { InferUITools, ToolUIPart } from \"ai\";\nimport { useCallback, useMemo } from \"react\";\nimport { Shimmer } from \"../shimmer\";\nimport { Steps, StepsContent, StepsItem, StepsTrigger } from \"../steps\";\n\nexport interface GlobProps {\n  part: ToolUIPart<InferUITools<Pick<Tools, \"glob\">>>;\n}\n\nexport function Glob({ part: { state, input, output } }: GlobProps) {\n  const isLoading = [\"input-streaming\", \"input-available\"].includes(state);\n\n  const renderMatch = useCallback((match: string) => {\n    const isDirectory = match.endsWith(\"/\");\n    const cleanPath = isDirectory ? match.slice(0, -1) : match;\n    const parts = cleanPath.split(\"/\");\n    const fileName = parts[parts.length - 1];\n    const dirPath = parts.slice(0, -1).join(\"/\");\n\n    return (\n      <div className=\"flex items-center gap-2 py-0.5 text-xs\">\n        {isDirectory ? (\n          <FolderIcon className=\"size-4\" weight=\"duotone\" />\n        ) : (\n          <FileIcon className=\"size-4\" weight=\"duotone\" />\n        )}\n        <span>\n          {dirPath && <span className=\"text-muted-foreground\">{dirPath}/</span>}\n          <span className=\"font-medium\">{fileName}</span>\n        </span>\n      </div>\n    );\n  }, []);\n\n  const results = useMemo(() => {\n    if (!Array.isArray(output?.metadata?.matches)) return null;\n\n    const matches = output.metadata.matches as string[];\n    const totalMatches =\n      typeof output.metadata?.count === \"number\"\n        ? output.metadata.count\n        : matches.length;\n\n    return (\n      <div className=\"flex flex-col gap-2\">\n        {/* Pattern and path */}\n        <div className=\"flex flex-col gap-1\">\n          <div className=\"text-xs\">\n            <span className=\"text-muted-foreground\">Pattern: </span>\n            <code className=\"rounded bg-muted/50 px-1 py-0.5 font-mono\">\n              {input?.pattern}\n            </code>\n          </div>\n          {input?.path && (\n            <div className=\"text-xs\">\n              <span className=\"text-muted-foreground\">In: </span>\n              <code className=\"font-mono\">{input.path}</code>\n            </div>\n          )}\n        </div>\n\n        {/* Results */}\n        <div className=\"mt-1\">\n          <div className=\"mb-1 text-muted-foreground text-xs\">\n            Found {totalMatches} match{totalMatches !== 1 ? \"es\" : \"\"}\n          </div>\n          {matches.length > 0 ? (\n            <div className=\"max-h-[300px] overflow-y-auto border-muted border-l-2 pl-2\">\n              {matches.slice(0, 100).map((match, index) => (\n                <div key={`${match}-${index}`}>{renderMatch(match)}</div>\n              ))}\n              {matches.length > 100 && (\n                <div className=\"mt-2 text-muted-foreground text-xs\">\n                  ... and {matches.length - 100} more\n                </div>\n              )}\n            </div>\n          ) : (\n            <span className=\"text-muted-foreground text-xs italic\">\n              No files found matching this pattern\n            </span>\n          )}\n        </div>\n      </div>\n    );\n  }, [input?.path, input?.pattern, output?.metadata, renderMatch]);\n\n  return (\n    <Steps data-tool-glob>\n      <StepsTrigger\n        leftIcon={\n          <FileMagnifyingGlassIcon weight=\"duotone\" className=\"size-4\" />\n        }\n        loading={isLoading}\n        error={output?.status === \"error\" || Boolean(output?.error)}\n      >\n        <div className=\"flex items-center gap-2\">\n          <span>Glob pattern: </span>\n          <code className=\"rounded bg-muted/50 px-1 py-0.5 font-mono text-xs\">\n            {input?.pattern}\n          </code>\n        </div>\n      </StepsTrigger>\n      <StepsContent>\n        {isLoading && (\n          <StepsItem className=\"flex items-center gap-2 text-muted-foreground text-xs\">\n            <Shimmer>Searching files...</Shimmer>\n          </StepsItem>\n        )}\n        {results && <StepsItem>{results}</StepsItem>}\n        {output?.error?.message && (\n          <StepsItem className=\"text-red-600 text-xs\">\n            {output.error.message}\n          </StepsItem>\n        )}\n      </StepsContent>\n    </Steps>\n  );\n}\n",
      "type": "registry:component",
      "target": "components/agent/tools/glob.tsx"
    },
    {
      "path": "src/registry/agentstart/tools/grep.tsx",
      "content": "/* agent-frontmatter:start\nAGENT: Grep tool UI component\nPURPOSE: Display code search results from grep tool with syntax highlighting\nUSAGE: <Grep part={toolPart} />\nEXPORTS: Grep, GrepProps\nFEATURES:\n  - Shows search pattern and matched content\n  - Supports multiple output modes (content/files/count)\n  - Syntax highlighting for matched code lines\n  - Displays file paths and line numbers with matches\nSEARCHABLE: grep tool, code search ui, content search results\nagent-frontmatter:end */\n\nimport { FileIcon, HashIcon } from \"@phosphor-icons/react\";\nimport type { Tools } from \"agentstart/agent\";\nimport type { InferUITools, ToolUIPart } from \"ai\";\nimport { CodeBlock } from \"../code-block\";\nimport { Shimmer } from \"../shimmer\";\nimport { Steps, StepsContent, StepsItem, StepsTrigger } from \"../steps\";\n\nexport interface GrepProps {\n  part: ToolUIPart<InferUITools<Pick<Tools, \"grep\">>>;\n}\n\nexport function Grep({ part: { state, input, output } }: GrepProps) {\n  const isLoading = [\"input-streaming\", \"input-available\"].includes(state);\n\n  const getOutputModeLabel = () => {\n    switch (input?.outputMode) {\n      case \"content\":\n        return \"Matching Lines\";\n      case \"count\":\n        return \"Match Counts\";\n      // case \"files_with_matches\":\n      default:\n        return \"Matching Files\";\n    }\n  };\n\n  const renderFilesOutput = () => {\n    const files = Array.isArray(output?.metadata?.files)\n      ? (output.metadata.files as string[])\n      : [];\n    if (files.length === 0) {\n      return (\n        <span className=\"text-muted-foreground text-xs italic\">\n          No files found with matches\n        </span>\n      );\n    }\n\n    const maxFiles = 100;\n    const displayFiles = files.slice(0, maxFiles);\n    const hasMore = files.length > maxFiles;\n\n    return (\n      <div className=\"mt-2\">\n        <div className=\"mb-1 text-muted-foreground text-xs\">\n          Found in {output?.metadata?.fileCount ?? files.length} file\n          {(output?.metadata?.fileCount ?? files.length) !== 1 && \"s\"}\n        </div>\n        <div className=\"max-h-[300px] overflow-y-auto border-muted border-l-2 pl-2\">\n          {displayFiles.map((file, index) => (\n            <div\n              key={`${file}-${index}`}\n              className=\"flex items-center gap-2 py-0.5 text-xs\"\n            >\n              <FileIcon className=\"size-4\" weight=\"duotone\" />\n              <span className=\"font-mono\">{file}</span>\n            </div>\n          ))}\n          {hasMore && (\n            <div className=\"mt-2 text-muted-foreground text-xs\">\n              {`// ... and ${files.length - maxFiles} more`}\n            </div>\n          )}\n        </div>\n      </div>\n    );\n  };\n\n  const renderCountsOutput = () => {\n    const counts = Array.isArray(output?.metadata?.counts)\n      ? (output.metadata.counts as Array<{ filename: string; count: number }>)\n      : [];\n    if (counts.length === 0) {\n      return (\n        <span className=\"text-muted-foreground text-xs italic\">\n          No matches found\n        </span>\n      );\n    }\n\n    return (\n      <div className=\"mt-2\">\n        <div className=\"mb-1 text-muted-foreground text-xs\">\n          Total: {output?.metadata?.totalMatches || 0} match\n          {(output?.metadata?.totalMatches || 0) !== 1 && \"es\"} in{\" \"}\n          {counts.length} file{counts.length !== 1 && \"s\"}\n        </div>\n        <div className=\"max-h-[300px] space-y-0.5 overflow-y-auto font-mono text-xs\">\n          {counts.map((item, index) => (\n            <div\n              key={`${item.filename}-${index}`}\n              className=\"flex items-center gap-2 rounded px-1 py-0.5 hover:bg-muted/50\"\n            >\n              <HashIcon className=\"size-4\" weight=\"duotone\" />\n              <span className=\"w-12 text-right text-blue-600\">\n                {item.count}\n              </span>\n              <span>{item.filename}</span>\n            </div>\n          ))}\n        </div>\n      </div>\n    );\n  };\n\n  const renderContentOutput = () => {\n    const matches = Array.isArray(output?.metadata?.matches)\n      ? (output.metadata.matches as string[])\n      : [];\n    if (matches.length === 0) {\n      return (\n        <span className=\"text-muted-foreground text-xs italic\">\n          No matching lines found\n        </span>\n      );\n    }\n\n    // Join all matches into a single string for the code block\n    const content = matches.join(\"\\n\");\n\n    return (\n      <div className=\"mt-2\">\n        <div className=\"mb-1 text-muted-foreground text-xs\">\n          Found {output?.metadata?.matchCount || 0} match\n          {(output?.metadata?.matchCount || 0) !== 1 && \"es\"} in{\" \"}\n          {output?.metadata?.fileCount || 0} file\n          {(output?.metadata?.fileCount || 0) !== 1 && \"s\"}\n        </div>\n        <CodeBlock code={content} language=\"markdown\" />\n      </div>\n    );\n  };\n\n  const renderResults = () => {\n    if (!output) return null;\n\n    return (\n      <div className=\"flex flex-col gap-2\">\n        {/* Pattern and options */}\n        <div className=\"flex flex-col gap-1\">\n          <div className=\"text-xs\">\n            <span className=\"text-muted-foreground\">Pattern: </span>\n            <code className=\"rounded bg-muted/50 px-1 py-0.5 font-mono\">\n              {input?.pattern}\n            </code>\n          </div>\n          {input?.path && (\n            <div className=\"text-xs\">\n              <span className=\"text-muted-foreground\">In: </span>\n              <code className=\"font-mono\">{input.path}</code>\n            </div>\n          )}\n          {input?.outputMode && (\n            <div className=\"text-xs\">\n              <span className=\"text-muted-foreground\">Mode: </span>\n              <span>{getOutputModeLabel()}</span>\n            </div>\n          )}\n        </div>\n\n        {/* Results based on output mode */}\n        {input?.outputMode === \"files_with_matches\" || !input?.outputMode\n          ? renderFilesOutput()\n          : input?.outputMode === \"count\"\n            ? renderCountsOutput()\n            : renderContentOutput()}\n      </div>\n    );\n  };\n\n  return (\n    <Steps data-tool-grep>\n      <StepsTrigger\n        leftIcon={<HashIcon weight=\"duotone\" className=\"size-4\" />}\n        loading={isLoading}\n        error={output?.status === \"error\" || Boolean(output?.error)}\n      >\n        <div className=\"flex items-center gap-2\">\n          <span>Search pattern: </span>\n          <code className=\"rounded bg-muted/50 px-1 py-0.5 font-mono text-xs\">\n            {input?.pattern}\n          </code>\n        </div>\n      </StepsTrigger>\n      <StepsContent>\n        {isLoading && (\n          <StepsItem className=\"flex items-center gap-2 text-muted-foreground text-xs\">\n            <Shimmer>Searching code...</Shimmer>\n          </StepsItem>\n        )}\n        <StepsItem>{renderResults()}</StepsItem>\n        {output?.error?.message && (\n          <StepsItem className=\"text-red-600 text-xs\">\n            {output.error.message}\n          </StepsItem>\n        )}\n      </StepsContent>\n    </Steps>\n  );\n}\n",
      "type": "registry:component",
      "target": "components/agent/tools/grep.tsx"
    },
    {
      "path": "src/registry/agentstart/tools/ls.tsx",
      "content": "/* agent-frontmatter:start\nAGENT: Ls tool UI component\nPURPOSE: Display directory listings from the ls tool with file metadata\nUSAGE: <Ls part={toolPart} />\nEXPORTS: Ls, LsProps\nFEATURES:\n  - Renders file/directory/symlink entries with appropriate icons\n  - Shows file sizes and modification dates\n  - Distinguishes file types with color-coded icons\n  - Displays tool execution state (pending/success/error)\nSEARCHABLE: ls tool, directory listing, file browser ui\nagent-frontmatter:end */\n\nimport { formatDate, formatSize } from \"@agentstart/utils\";\nimport { FileIcon, FolderIcon, LinkIcon } from \"@phosphor-icons/react\";\nimport type { Tools } from \"agentstart/agent\";\nimport type { InferUITools, ToolUIPart } from \"ai\";\nimport { useCallback, useMemo } from \"react\";\nimport { Shimmer } from \"../shimmer\";\nimport { Steps, StepsContent, StepsItem, StepsTrigger } from \"../steps\";\n\nexport interface LsProps {\n  part: ToolUIPart<InferUITools<Pick<Tools, \"ls\">>>;\n}\n\nexport function Ls({ part: { state, input, output } }: LsProps) {\n  const isLoading = [\"input-streaming\", \"input-available\"].includes(state);\n\n  const getIcon = useCallback((entryType: \"file\" | \"directory\" | \"symlink\") => {\n    switch (entryType) {\n      case \"directory\":\n        return <FolderIcon className=\"size-4\" weight=\"duotone\" />;\n      case \"symlink\":\n        return <LinkIcon className=\"size-4\" weight=\"duotone\" />;\n      default:\n        return <FileIcon className=\"size-4\" weight=\"duotone\" />;\n    }\n  }, []);\n\n  const entries = useMemo(() => {\n    if (!Array.isArray(output?.metadata?.entries)) return null;\n    type LsEntry = {\n      type: \"file\" | \"directory\" | \"symlink\";\n      name: string;\n      size: number;\n      modifiedTime: number;\n    };\n    const entries = output.metadata.entries as LsEntry[];\n\n    return (\n      <div>\n        {entries.length > 0 ? (\n          <div className=\"space-y-0.5 font-mono text-xs\">\n            {entries.map((entry, index) => (\n              <div\n                key={`${entry.name}-${index}`}\n                className=\"flex items-center gap-2 rounded px-1 py-0.5 hover:bg-muted/50\"\n              >\n                {getIcon(entry.type)}\n                <span className=\"w-12 text-right text-muted-foreground\">\n                  {entry.type === \"directory\" ? \"-\" : formatSize(entry.size)}\n                </span>\n                <span className=\"text-muted-foreground\">\n                  {formatDate(entry.modifiedTime)}\n                </span>\n                <span\n                  className={\n                    entry.type === \"directory\"\n                      ? \"font-medium text-muted-foreground\"\n                      : \"text-foreground\"\n                  }\n                >\n                  {entry.name}\n                  {entry.type === \"directory\" && \"/\"}\n                  {entry.type === \"symlink\" && \" \"}\n                </span>\n              </div>\n            ))}\n          </div>\n        ) : (\n          <span className=\"text-muted-foreground text-xs italic\">\n            Directory is empty\n          </span>\n        )}\n      </div>\n    );\n  }, [getIcon, output?.metadata]);\n\n  return (\n    <Steps data-tool-ls>\n      <StepsTrigger\n        leftIcon={<FolderIcon weight=\"duotone\" className=\"size-4\" />}\n        loading={isLoading}\n        error={output?.status === \"error\" || Boolean(output?.error)}\n      >\n        <div className=\"flex items-center gap-2\">\n          <span>Directory: </span>\n          <code className=\"font-mono text-xs\">{input?.path || \"/\"}</code>\n          <div className=\"text-muted-foreground text-xs\">\n            {output?.metadata?.count || 0} item\n            {(output?.metadata?.count || 0) !== 1 && \"s\"}\n          </div>\n        </div>\n      </StepsTrigger>\n      <StepsContent>\n        {isLoading && (\n          <StepsItem className=\"flex items-center gap-2 text-muted-foreground text-xs\">\n            <Shimmer>Listing directory...</Shimmer>\n          </StepsItem>\n        )}\n        {entries && <StepsItem>{entries}</StepsItem>}\n        {output?.error?.message && (\n          <StepsItem className=\"text-red-600 text-xs\">\n            {output.error.message}\n          </StepsItem>\n        )}\n      </StepsContent>\n    </Steps>\n  );\n}\n",
      "type": "registry:component",
      "target": "components/agent/tools/ls.tsx"
    },
    {
      "path": "src/registry/agentstart/tools/read.tsx",
      "content": "/* agent-frontmatter:start\nAGENT: Read file tool UI component\nPURPOSE: Display file reading operations with syntax-highlighted content\nUSAGE: <ReadFile part={toolPart} />\nEXPORTS: ReadFile, ReadFileProps\nFEATURES:\n  - Shows file path and reading range (offset/limit)\n  - Syntax highlighting based on file extension\n  - Displays file content with line numbers\n  - Handles partial file reads with range indicators\nSEARCHABLE: read tool, file view ui, code viewer\nagent-frontmatter:end */\n\nimport { getLanguageFromFilePath } from \"@agentstart/utils\";\nimport { SunglassesIcon } from \"@phosphor-icons/react\";\nimport type { Tools } from \"agentstart/agent\";\nimport type { InferUITools, ToolUIPart } from \"ai\";\nimport { useMemo } from \"react\";\nimport {\n  Tooltip,\n  TooltipContent,\n  TooltipTrigger,\n} from \"@/components/ui/tooltip\";\nimport { CodeBlock } from \"../code-block\";\nimport { Shimmer } from \"../shimmer\";\nimport { Steps, StepsContent, StepsItem, StepsTrigger } from \"../steps\";\n\nexport interface ReadFileProps {\n  part: ToolUIPart<InferUITools<Pick<Tools, \"read\">>>;\n}\n\nexport function ReadFile({ part: { state, input, output } }: ReadFileProps) {\n  const fileName = input?.filePath?.split(\"/\").pop() || input?.filePath;\n  const readingRange = useMemo(() => {\n    if (input?.offset === undefined && input?.limit === undefined) {\n      return null;\n    }\n    const start = input.offset ?? 0;\n    const end = input.limit ? start + input.limit : \"end\";\n    return `Lines ${start + 1} - ${end}`;\n  }, [input]);\n\n  const preview = useMemo(() => {\n    if (!output?.metadata?.content) return null;\n    const lines = output.metadata.content.split(\"\\n\");\n    const maxLines = 10;\n    const hasMore = lines.length > maxLines;\n    const language = getLanguageFromFilePath(input?.filePath);\n\n    const previewLines = lines.slice(0, maxLines);\n    const preview = hasMore\n      ? [\n          ...previewLines,\n          `// ... and ${lines.length - maxLines} more lines`,\n        ].join(\"\\n\")\n      : previewLines.join(\"\\n\");\n\n    return (\n      <CodeBlock\n        code={preview}\n        copyCode={output.metadata.content}\n        language={language}\n      />\n    );\n  }, [output?.metadata?.content, input?.filePath]);\n\n  const title = useMemo(() => {\n    return (\n      <Tooltip>\n        <TooltipTrigger\n          render={\n            <div className=\"flex items-center gap-2\">\n              <span>{fileName}</span>\n              {readingRange && (\n                <span className=\"text-muted-foreground/60\">{readingRange}</span>\n              )}\n            </div>\n          }\n        />\n        {input?.filePath && <TooltipContent>{input.filePath}</TooltipContent>}\n      </Tooltip>\n    );\n  }, [fileName, readingRange, input?.filePath]);\n  const isLoading = [\"input-streaming\", \"input-available\"].includes(state);\n\n  return (\n    <Steps data-tool-read>\n      <StepsTrigger\n        leftIcon={<SunglassesIcon weight=\"duotone\" className=\"size-4\" />}\n        loading={isLoading}\n        error={output?.status === \"error\" || Boolean(output?.error)}\n      >\n        {title}\n      </StepsTrigger>\n      <StepsContent>\n        {isLoading && (\n          <StepsItem className=\"flex items-center gap-2 text-muted-foreground text-xs\">\n            <Shimmer>Reading file...</Shimmer>\n          </StepsItem>\n        )}\n        {preview && <StepsItem>{preview}</StepsItem>}\n        {output?.error?.message && (\n          <StepsItem className=\"text-red-600 text-xs\">\n            {output.error.message}\n          </StepsItem>\n        )}\n      </StepsContent>\n    </Steps>\n  );\n}\n",
      "type": "registry:component",
      "target": "components/agent/tools/read.tsx"
    },
    {
      "path": "src/registry/agentstart/tools/write.tsx",
      "content": "/* agent-frontmatter:start\nAGENT: Write file tool UI component\nPURPOSE: Display file writing operations with content preview\nUSAGE: <WriteFile part={toolPart} />\nEXPORTS: WriteFile, WriteFileProps\nFEATURES:\n  - Shows file path and write operation\n  - Preview first 10 lines of content with syntax highlighting\n  - Indicates when content is truncated\n  - Language detection based on file extension\nSEARCHABLE: write tool, file creation ui, save file view\nagent-frontmatter:end */\n\nimport { getLanguageFromFilePath } from \"@agentstart/utils\";\nimport { NotePencilIcon } from \"@phosphor-icons/react\";\nimport type { Tools } from \"agentstart/agent\";\nimport type { InferUITools, ToolUIPart } from \"ai\";\nimport { useMemo } from \"react\";\nimport {\n  Tooltip,\n  TooltipContent,\n  TooltipTrigger,\n} from \"@/components/ui/tooltip\";\nimport { CodeBlock } from \"../code-block\";\nimport { Shimmer } from \"../shimmer\";\nimport { Steps, StepsContent, StepsItem, StepsTrigger } from \"../steps\";\n\nexport interface WriteFileProps {\n  part: ToolUIPart<InferUITools<Pick<Tools, \"write\">>>;\n}\n\nexport function WriteFile({ part: { state, input, output } }: WriteFileProps) {\n  const fileName = input?.filePath?.split(\"/\").pop() || input?.filePath;\n  const fileContent = input?.content?.replace(/\\\\n/g, \"\\n\");\n  const isLoading = [\"input-streaming\", \"input-available\"].includes(state);\n\n  const preview = useMemo(() => {\n    if (!input || !fileContent) return null;\n    const lines = fileContent.split(\"\\n\");\n    const maxLines = 10;\n    const hasMore = lines.length > maxLines;\n    const language = getLanguageFromFilePath(input.filePath);\n\n    const previewLines = lines.slice(0, maxLines);\n\n    // Generate diff code with all lines marked as additions\n    const diffLines = previewLines.map((line) =>\n      line.trim() ? `${line} // [!code ++]` : \"\",\n    );\n    if (hasMore) {\n      diffLines.push(`// ... and ${lines.length - maxLines} more lines`);\n    }\n    const diffCode = diffLines.join(\"\\n\");\n\n    return (\n      <CodeBlock\n        code={diffCode}\n        copyCode={fileContent}\n        language={language}\n        showDiff\n      />\n    );\n  }, [input, fileContent]);\n\n  const title = useMemo(() => {\n    if (!input || !fileContent) return null;\n\n    const lineNumber = fileContent.split(\"\\n\").length ?? 0;\n    return (\n      <div className=\"flex items-center gap-2\">\n        <Tooltip>\n          <TooltipTrigger render={<span>{fileName}</span>} />\n          {input?.filePath && <TooltipContent>{input.filePath}</TooltipContent>}\n        </Tooltip>\n        <span className=\"text-green-600\">(new) +{lineNumber}</span>\n      </div>\n    );\n  }, [input, fileName, fileContent]);\n\n  return (\n    <Steps data-tool-write>\n      <StepsTrigger\n        leftIcon={<NotePencilIcon weight=\"duotone\" className=\"size-4\" />}\n        loading={isLoading}\n        error={output?.status === \"error\" || Boolean(output?.error)}\n      >\n        {title}\n      </StepsTrigger>\n      <StepsContent>\n        {isLoading && (\n          <StepsItem className=\"flex items-center gap-2 text-muted-foreground text-xs\">\n            <Shimmer>Writing file...</Shimmer>\n          </StepsItem>\n        )}\n        {preview && <StepsItem>{preview}</StepsItem>}\n        {output?.error?.message && (\n          <StepsItem className=\"text-red-600 text-xs\">\n            {output.error.message}\n          </StepsItem>\n        )}\n      </StepsContent>\n    </Steps>\n  );\n}\n",
      "type": "registry:component",
      "target": "components/agent/tools/write.tsx"
    },
    {
      "path": "src/registry/agentstart/tools/edit.tsx",
      "content": "/* agent-frontmatter:start\nAGENT: Edit file tool UI component\nPURPOSE: Visualize file edit operations with unified diff view\nUSAGE: <EditFile part={toolPart} />\nEXPORTS: EditFile, EditFileProps\nFEATURES:\n  - Shows unified diff with syntax highlighting\n  - Displays file path and operation type (replace/replaceAll)\n  - Uses [!code --] and [!code ++] markers for changes\n  - Supports replace_all flag visualization\nSEARCHABLE: edit tool, file edit ui, code replacement view, diff view\nagent-frontmatter:end */\n\nimport { getLanguageFromFilePath } from \"@agentstart/utils\";\nimport { SwapIcon } from \"@phosphor-icons/react\";\nimport type { Tools } from \"agentstart/agent\";\nimport type { InferUITools, ToolUIPart } from \"ai\";\nimport { useMemo } from \"react\";\nimport {\n  Tooltip,\n  TooltipContent,\n  TooltipTrigger,\n} from \"@/components/ui/tooltip\";\nimport { CodeBlock } from \"../code-block\";\nimport { Shimmer } from \"../shimmer\";\nimport { Steps, StepsContent, StepsItem, StepsTrigger } from \"../steps\";\n\nexport interface EditFileProps {\n  part: ToolUIPart<InferUITools<Pick<Tools, \"edit\">>>;\n}\n\nexport function EditFile({ part: { state, input, output } }: EditFileProps) {\n  const fileName = input?.filePath?.split(\"/\").pop() || input?.filePath;\n\n  const language = getLanguageFromFilePath(input?.filePath || \"\");\n\n  const isLoading = [\"input-streaming\", \"input-available\"].includes(state);\n\n  const changes = useMemo(() => {\n    if (!input || !input.oldString || !input.newString) return null;\n\n    // Always show as unified diff\n    const oldLines = input.oldString.split(\"\\n\");\n    const newLines = input.newString.split(\"\\n\");\n    const diffCode = [\n      ...oldLines.map((line) => `${line} // [!code --]`),\n      ...newLines.map((line) => `${line} // [!code ++]`),\n    ].join(\"\\n\");\n\n    return (\n      <CodeBlock\n        code={diffCode}\n        copyCode={input.newString}\n        language={language}\n        showDiff\n      />\n    );\n  }, [input, language]);\n\n  return (\n    <Steps data-tool-edit>\n      <StepsTrigger\n        leftIcon={<SwapIcon weight=\"duotone\" className=\"size-4\" />}\n        loading={isLoading}\n        error={output?.status === \"error\" || Boolean(output?.error)}\n      >\n        <div className=\"flex items-center gap-2\">\n          <Tooltip>\n            <TooltipTrigger\n              render={<code className=\"text-xs\">{fileName}</code>}\n            />\n            {input?.filePath && (\n              <TooltipContent>{input.filePath}</TooltipContent>\n            )}\n          </Tooltip>\n          {input?.replaceAll && (\n            <span className=\"text-muted-foreground text-xs\">(replace all)</span>\n          )}\n        </div>\n      </StepsTrigger>\n      <StepsContent>\n        {isLoading && (\n          <StepsItem className=\"flex items-center gap-2 text-muted-foreground text-xs\">\n            <Shimmer>Editing file...</Shimmer>\n          </StepsItem>\n        )}\n        <StepsItem>\n          <div className=\"flex items-center gap-2\">\n            {input?.replaceAll && (\n              <span className=\"text-muted-foreground text-xs\">\n                (replace all)\n              </span>\n            )}\n          </div>\n        </StepsItem>\n        {changes && <StepsItem>{changes}</StepsItem>}\n        {output?.error?.message && (\n          <StepsItem className=\"text-red-600 text-xs\">\n            {output.error.message}\n          </StepsItem>\n        )}\n      </StepsContent>\n    </Steps>\n  );\n}\n",
      "type": "registry:component",
      "target": "components/agent/tools/edit.tsx"
    },
    {
      "path": "src/registry/agentstart/tools/todo.tsx",
      "content": "/* agent-frontmatter:start\nAGENT: Todo tool UI component\nPURPOSE: Display task list from todo tool with status indicators\nUSAGE: <Todo part={toolPart} />\nEXPORTS: Todo, TodoProps\nFEATURES:\n  - Shows todos grouped by status (inProgress, pending, completed)\n  - Color-coded status icons (blue pulse, gray circle, green check)\n  - Displays active/pending forms for each task\n  - Error state visualization for failed operations\nSEARCHABLE: todo tool, task list ui, progress tracker\nagent-frontmatter:end */\n\nimport {\n  CheckIcon,\n  CircleIcon,\n  ClockIcon,\n  KanbanIcon,\n  WarningIcon,\n} from \"@phosphor-icons/react\";\nimport type { Tools } from \"agentstart/agent\";\nimport type { InferUITools, ToolUIPart } from \"ai\";\nimport type React from \"react\";\nimport { useMemo } from \"react\";\nimport { cn } from \"@/lib/utils\";\nimport { Shimmer } from \"../shimmer\";\nimport { Steps, StepsContent, StepsItem, StepsTrigger } from \"../steps\";\n\nconst statusOrder = [\"inProgress\", \"pending\", \"completed\"];\n\nconst statusIcons: Record<string, React.ReactNode> = {\n  completed: <CheckIcon className=\"size-3.5 text-green-600\" />,\n  inProgress: <ClockIcon className=\"size-3.5 animate-pulse text-blue-600\" />,\n  pending: <CircleIcon className=\"size-3.5 text-muted-foreground\" />,\n};\n\nconst getStatusIcon = (status: string) => statusIcons[status] ?? null;\n\nconst priorityColors: Record<string, string> = {\n  high: \"text-red-600\",\n  medium: \"text-yellow-600\",\n  low: \"text-muted-foreground\",\n};\n\nconst getPriorityColor = (priority: string) =>\n  priorityColors[priority] ?? \"text-muted-foreground\";\n\nconst priorityBadges: Record<string, string> = {\n  high: \"\",\n  medium: \"\",\n  low: \"\",\n};\n\nconst getPriorityBadge = (priority: string) => (\n  <span className={cn(\"text-xs\", getPriorityColor(priority))}>\n    {priorityBadges[priority] ?? \"\"}\n  </span>\n);\n\nexport interface TodoProps {\n  part:\n    | ToolUIPart<InferUITools<Pick<Tools, \"todoRead\">>>\n    | ToolUIPart<InferUITools<Pick<Tools, \"todoWrite\">>>;\n}\n\nexport function Todo({ part: { state, output, errorText } }: TodoProps) {\n  const isLoading = [\"input-streaming\", \"input-available\"].includes(state);\n\n  const todos = output?.metadata?.todos || [];\n\n  const groupedTodos = todos.reduce(\n    (acc, todo) => {\n      const group = acc[todo.status] || [];\n      return {\n        ...acc,\n        [todo.status]: [...group, todo],\n      };\n    },\n    {} as Record<string, typeof todos>,\n  );\n\n  const todoListContent = useMemo(() => {\n    if (output?.error) {\n      return (\n        <div className=\"flex items-center gap-2 text-red-600\">\n          <WarningIcon className=\"size-4\" weight=\"duotone\" />\n          <span className=\"text-xs\">{output.prompt}</span>\n        </div>\n      );\n    }\n\n    if (!output) {\n      return null;\n    }\n\n    if (todos.length === 0) {\n      return (\n        <div className=\"text-muted-foreground text-xs italic\">\n          No tasks in the list\n        </div>\n      );\n    }\n\n    return (\n      <div className=\"space-y-3\">\n        {statusOrder.map((status) => {\n          const statusTodos = groupedTodos[status];\n          if (!statusTodos || statusTodos.length === 0) return null;\n\n          return (\n            <div key={status}>\n              <div className=\"mb-1 font-medium text-muted-foreground text-xs capitalize\">\n                {status.replace(\"_\", \" \")}\n              </div>\n              <div className=\"space-y-1\">\n                {statusTodos.map((todo) => (\n                  <div\n                    key={todo.id}\n                    className={cn(\n                      \"flex items-start gap-2 rounded-sm p-1.5 text-xs transition-colors\",\n                      todo.status === \"completed\" && \"opacity-60\",\n                      todo.status === \"inProgress\" &&\n                        \"bg-blue-50 dark:bg-blue-900/20\",\n                      todo.priority === \"high\" &&\n                        todo.status !== \"completed\" &&\n                        \"bg-red-50 dark:bg-red-900/10\",\n                    )}\n                  >\n                    {getStatusIcon(todo.status)}\n                    <div className=\"flex-1\">\n                      <span\n                        className={cn(\n                          todo.status === \"completed\" && \"line-through\",\n                        )}\n                      >\n                        {todo.content}\n                      </span>\n                    </div>\n                    {getPriorityBadge(todo.priority)}\n                  </div>\n                ))}\n              </div>\n            </div>\n          );\n        })}\n      </div>\n    );\n  }, [output, todos.length, groupedTodos]);\n\n  return (\n    <Steps data-tool-todo>\n      <StepsTrigger\n        leftIcon={<KanbanIcon weight=\"duotone\" className=\"size-4\" />}\n        loading={isLoading}\n        error={output?.status === \"error\" || Boolean(output?.error)}\n      >\n        <span>Task List</span>\n      </StepsTrigger>\n      <StepsContent>\n        {isLoading && (\n          <StepsItem className=\"flex items-center gap-2 text-muted-foreground text-xs\">\n            <Shimmer>\n              {output ? \"Updating tasks...\" : \"Loading tasks...\"}\n            </Shimmer>\n          </StepsItem>\n        )}\n        {errorText && (\n          <StepsItem className=\"text-red-600 text-xs\">{errorText}</StepsItem>\n        )}\n        {todoListContent && <StepsItem>{todoListContent}</StepsItem>}\n      </StepsContent>\n    </Steps>\n  );\n}\n",
      "type": "registry:component",
      "target": "components/agent/tools/todo.tsx"
    },
    {
      "path": "src/registry/agentstart/tools/reasoning.tsx",
      "content": "/* agent-frontmatter:start\nAGENT: Reasoning disclosure widget\nPURPOSE: Show expandable reasoning traces with streaming-aware behavior\nUSAGE: import { Reasoning, ReasoningTrigger, ReasoningContent } from \\\"@/components/agent/reasoning\\\"\nEXPORTS: Reasoning, ReasoningTrigger, ReasoningContent\nFEATURES:\n  - Auto-opens while streaming and auto-closes after completion\n  - Displays duration summaries and shimmer placeholder\nSEARCHABLE: reasoning panel, collapsible thinking, agent reasoning ui\nagent-frontmatter:end */\n\n\"use client\";\n\nimport { BrainIcon, CaretDownIcon } from \"@phosphor-icons/react\";\nimport type { ComponentProps } from \"react\";\nimport { createContext, memo, useContext, useEffect, useState } from \"react\";\n\n// Simple implementation of useControllableState for Base UI compatibility\nfunction useControllableState<T>({\n  prop,\n  defaultProp,\n  onChange,\n}: {\n  prop?: T;\n  defaultProp: T;\n  onChange?: (value: T) => void;\n}) {\n  const [state, setState] = useState(prop ?? defaultProp);\n\n  useEffect(() => {\n    if (prop !== undefined) {\n      setState(prop);\n    }\n  }, [prop]);\n\n  const setValue = (value: T) => {\n    if (prop === undefined) {\n      setState(value);\n    }\n    onChange?.(value);\n  };\n\n  return [state, setValue] as const;\n}\n\nimport { cn } from \"@/lib/utils\";\nimport { Response } from \"../response\";\nimport { Shimmer } from \"../shimmer\";\nimport { Steps, StepsContent, StepsItem, StepsTrigger } from \"../steps\";\n\ntype ReasoningContextValue = {\n  isStreaming: boolean;\n  isOpen: boolean;\n  setIsOpen: (open: boolean) => void;\n  duration: number;\n};\n\nconst ReasoningContext = createContext<ReasoningContextValue | null>(null);\n\nconst useReasoning = () => {\n  const context = useContext(ReasoningContext);\n  if (!context) {\n    throw new Error(\"Reasoning components must be used within Reasoning\");\n  }\n  return context;\n};\n\nexport type ReasoningProps = ComponentProps<typeof Steps> & {\n  isStreaming?: boolean;\n  open?: boolean;\n  defaultOpen?: boolean;\n  onOpenChange?: (open: boolean) => void;\n  duration?: number;\n};\n\nconst AUTO_CLOSE_DELAY = 1000;\nconst MS_IN_S = 1000;\n\nexport const Reasoning = memo(\n  ({\n    className,\n    isStreaming = false,\n    open,\n    defaultOpen = true,\n    onOpenChange,\n    duration: durationProp,\n    children,\n    ...props\n  }: ReasoningProps) => {\n    const [isOpen, setIsOpen] = useControllableState({\n      prop: open,\n      defaultProp: defaultOpen,\n      onChange: onOpenChange,\n    });\n    const [duration, setDuration] = useControllableState({\n      prop: durationProp,\n      defaultProp: 0,\n    });\n\n    const [hasAutoClosed, setHasAutoClosed] = useState(false);\n    const [startTime, setStartTime] = useState<number | null>(null);\n\n    // Track duration when streaming starts and ends\n    useEffect(() => {\n      if (isStreaming) {\n        if (startTime === null) {\n          setStartTime(Date.now());\n        }\n      } else if (startTime !== null) {\n        setDuration(Math.ceil((Date.now() - startTime) / MS_IN_S));\n        setStartTime(null);\n      }\n    }, [isStreaming, startTime, setDuration]);\n\n    // Auto-open when streaming starts, auto-close when streaming ends (once only)\n    useEffect(() => {\n      if (defaultOpen && !isStreaming && isOpen && !hasAutoClosed) {\n        // Add a small delay before closing to allow user to see the content\n        const timer = setTimeout(() => {\n          setIsOpen(false);\n          setHasAutoClosed(true);\n        }, AUTO_CLOSE_DELAY);\n\n        return () => clearTimeout(timer);\n      }\n    }, [isStreaming, isOpen, defaultOpen, setIsOpen, hasAutoClosed]);\n\n    const handleOpenChange = (newOpen: boolean) => {\n      setIsOpen(newOpen);\n    };\n\n    return (\n      <ReasoningContext.Provider\n        value={{ isStreaming, isOpen, setIsOpen, duration }}\n      >\n        <Steps\n          data-tool-reasoning\n          className={cn(\"not-prose\", className)}\n          onOpenChange={handleOpenChange}\n          open={isOpen}\n          {...props}\n        >\n          {children}\n        </Steps>\n      </ReasoningContext.Provider>\n    );\n  },\n);\n\nexport type ReasoningTriggerProps = ComponentProps<typeof StepsTrigger>;\n\nexport const getThinkingMessage = (isStreaming: boolean, duration?: number) => {\n  if (isStreaming || duration === 0) {\n    return <Shimmer duration={1}>Thinking...</Shimmer>;\n  }\n  if (duration === undefined) {\n    return <p>Thought for a few seconds</p>;\n  }\n  return <p>Thought for {duration} seconds</p>;\n};\n\nexport const ReasoningTrigger = memo(\n  ({ className, children, ...props }: ReasoningTriggerProps) => {\n    const { isStreaming, isOpen, duration } = useReasoning();\n\n    return (\n      <StepsTrigger\n        leftIcon={<BrainIcon className=\"size-4\" weight=\"duotone\" />}\n        loading={isStreaming}\n        className={cn(\n          \"flex w-full items-center gap-2 text-muted-foreground text-sm transition-colors hover:text-foreground\",\n          className,\n        )}\n        {...props}\n      >\n        {children ?? (\n          <>\n            {getThinkingMessage(isStreaming, duration)}\n            <CaretDownIcon\n              className={cn(\n                \"size-4 transition-transform\",\n                isOpen ? \"rotate-180\" : \"rotate-0\",\n              )}\n            />\n          </>\n        )}\n      </StepsTrigger>\n    );\n  },\n);\n\nexport type ReasoningContentProps = ComponentProps<typeof StepsContent> & {\n  children: string;\n};\n\nexport const ReasoningContent = memo(\n  ({ className, children, ...props }: ReasoningContentProps) => (\n    <StepsContent\n      className={cn(\n        \"data-[state=closed]:fade-out-0 data-[state=closed]:slide-out-to-top-2 data-[state=open]:slide-in-from-top-2 text-muted-foreground text-sm outline-none data-[state=closed]:animate-out data-[state=open]:animate-in\",\n        className,\n      )}\n      {...props}\n    >\n      <StepsItem>\n        <Response className=\"grid gap-2\">{children}</Response>\n      </StepsItem>\n    </StepsContent>\n  ),\n);\n\nReasoning.displayName = \"Reasoning\";\nReasoningTrigger.displayName = \"ReasoningTrigger\";\nReasoningContent.displayName = \"ReasoningContent\";\n",
      "type": "registry:component",
      "target": "components/agent/tools/reasoning.tsx"
    }
  ]
}